<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Awei</title>
    <link>https://wangwei9160.github.io/</link>
    <description>Recent content on Awei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 03 Apr 2021 22:23:17 +0800</lastBuildDate>
    
        <atom:link href="https://wangwei9160.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据库</title>
      <link>https://wangwei9160.github.io/post/sql/</link>
      <pubDate>Sat, 03 Apr 2021 22:23:17 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/sql/</guid>
      
        <description>&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;hr&gt;
</description>
      
    </item>
    
    <item>
      <title>挫败的人生r</title>
      <link>https://wangwei9160.github.io/post/loser/</link>
      <pubDate>Fri, 02 Apr 2021 17:00:01 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/loser/</guid>
      
        <description>&lt;h2 id=&#34;面&#34;&gt;面&lt;/h2&gt;
&lt;h3 id=&#34;第一次面&#34;&gt;第一次面&lt;/h3&gt;
&lt;p&gt;c++和python的感觉
右值引用
二分(匹配最后一个)
太久没有写面试算法题了，直接发蒙&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;
边界问题忘记了&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.
自己平时写代码的陋习体现了&amp;hellip;..喜欢盯着代码看&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.
能在相比其他的专业知识最擅长的地方挂了&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;..&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Stl</title>
      <link>https://wangwei9160.github.io/post/stl/</link>
      <pubDate>Tue, 30 Mar 2021 10:05:09 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/stl/</guid>
      
        <description>&lt;h1 id=&#34;stl&#34;&gt;STL&lt;/h1&gt;
&lt;p&gt;整理stl的内容，各个.h文件的主要内容&lt;/p&gt;
&lt;h2 id=&#34;六大组件&#34;&gt;六大组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;容器(containers)：各种数据结构，如vector,list,deque,set,map,主要用来存放数据。从实现的角度来看，stl容器是一种class template。&lt;/li&gt;
&lt;li&gt;算法(alogirithm)：各种常用算法，如sort,search,copy,erase&amp;hellip;。从实现的角度来看，stl算法是一种function template。&lt;/li&gt;
&lt;li&gt;迭代器(iterators)：泛型指针，从实现的角度来看，迭代器是一种将operator*,operator-&amp;gt;,operator++,operator&amp;ndash;等指针相关操作予以重载的class template，所有stl容器都附带自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。&lt;/li&gt;
&lt;li&gt;仿函数(functors)：行为类似函数，可作为算法的某种策略(policy)。从实现的角度来看，仿函数是一种重载了operator()的class或class template。一般函数指针可以视为狭义的仿函数。&lt;/li&gt;
&lt;li&gt;适配器(adapters)：一种用来修饰容器或仿函数或迭代器接口的东西，如queue和stack，只是容器适配器，它们的底层完全借助queue，所有操作由底层queue供应，改变functor接口者；改变iterator接口者，称为iterator adaptor。&lt;/li&gt;
&lt;li&gt;配置器(allocators)：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;memoryh&#34;&gt;memory.h&lt;/h4&gt;
&lt;p&gt;memory.h 内含件 alloc.h、construct.h、uninitialized.h
包含auto_ptr ，用来包装源生指针的对象，内存漏洞问题可以藉此解决&lt;/p&gt;
&lt;h4 id=&#34;constructh&#34;&gt;construct.h&lt;/h4&gt;
&lt;p&gt;construct.h 定义有两个基本函数：构造用的construct()和析构用的destroy()
construct()接受一个指针ptr和一个初值value，该函数的用途就是将初值设定到指针所指的空间上。
destroy()有两个版本：
第一个版本接受一个指针，准备将该指针指向的对象析构掉。直接掉用该对象的析构函数。
第二个版本接受first和last两个迭代器，准备讲[first，last)范围内的所有对象析构掉。&lt;/p&gt;
&lt;h4 id=&#34;alloch&#34;&gt;alloc.h&lt;/h4&gt;
&lt;p&gt;alloc.h 定义了一二级配置器，实现对象构造前的空间配置和独享析构后的空间释放
第一级配置器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allocate()直接使用malloc()、deallocate()直接使用free()。&lt;/li&gt;
&lt;li&gt;模拟c++的set_new_handler()以处理内存不足的状况。
第二级配置器：&lt;/li&gt;
&lt;li&gt;维护16个自由链表(free lists)负责16种小型区块的次配置能力。内存池以malloc()配置而得，如果内存不足，转调用第一级配置器。&lt;/li&gt;
&lt;li&gt;如果需求区块大于128bytes，就转调用第一级配置器。
第二级配置器共维护16个free-lists，各自管理的大小分别为8，16,24,32,40,48,56,64,72，80,88，96,104,112,120,128bytes。
union obj{
union obj * free_list_link;
char client_data[1] ;&lt;br&gt;
}
static obj * volatitle free_list[]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;static size_t FREELIST_INDEX(size_t bytes) 根据区块大小，决定使用第几号free-list,n从1算起&lt;/p&gt;
&lt;p&gt;static void * refill(size_t n) 返回一个大小为n的对象，并可能加入大小为n的其他区块到free list
当发现free list中没有可用区块的时候，就调用refill()，准备为free list 重新填充空间。新的空间将取自内存池(由chunk_alloc()完成)。缺省取得20个新节点(新区块)，万一内存池空间不足，获得的节点数(区块书)可能小于20.&lt;/p&gt;
&lt;p&gt;static char * chunk_alloc(size_t size , int &amp;amp;nobjs) 配置一大块空间，可容纳nobjs个大小为size的区块
从内存池中去空间给free list使用，是chunk_alloc()的工作。&lt;/p&gt;
&lt;p&gt;start_free 内存池起始位置。只能在chunk_alloc()中变化
end_free 内存池结束位置。只能在chunk_alloc()中变化
heap_size&lt;/p&gt;
&lt;p&gt;allocate(size_t n)
首先判断区块大小，大于128bytes就调用第一级配置器，小于128bytes就检查对应的free list，如果free list 之内有可用的区块，就直接用，如果没有可用区块，就将区块大小上调至8倍数变节，然后调用refill()，准备为free list重新填充空间。
deallocate(void *p , size_t n)
首先判断区块大小，大于128bytes就调用第一级配置器，小于128bytes就找出对应的free list，将区块回收。
reallocate(void *p , size_t old_size , size_t new_size)&lt;/p&gt;
&lt;h4 id=&#34;uninitializedh&#34;&gt;uninitialized.h&lt;/h4&gt;
&lt;p&gt;uninitialized.h 定义了一些全局函数，用来填充(fill)或复制(copy)大块内存数据。
uninitialized_copy(),uninitialized_fill(),uninitialized_fill_n()分别对应于高层次函数copy()、fill()、fill_n()。
uninitialized_fill_n()接受三个参数：
1、迭代器first指向欲初始化空间的起始处。
2、n表示欲初始化空间的大小。
3、x表示初值
uninitialized_copy() 接受三个参数：
1、迭代器first指向输入端的其实位置
2、迭代器last指向输入端的结束位置(前闭后开区间)
3、迭代器result指向输出端(欲初始化空间)的起始处
uninitialized_fill()接受三个参数：
1、迭代器first指向输出端(欲初始化空间)的起始处
2、迭代器last指向输出端(欲初始化空间)的借书处(前闭后开区间)
3、x表示初值&lt;/p&gt;
&lt;h2 id=&#34;allocator&#34;&gt;allocator&lt;/h2&gt;
&lt;h3 id=&#34;必要接口&#34;&gt;必要接口&lt;/h3&gt;
&lt;p&gt;allocator::value_type
allocator::pointer
allocator::const_pointer
allocator::reference
allocator::const_reference
allocator::size_type
allocator::difference_type
allocator::rebind
allocator::allocator()
allocator::allocator(const allocator&amp;amp;)
template&lt;!-- raw HTML omitted --&gt;allocator::allocator(const allocator&lt;!-- raw HTML omitted --&gt;&amp;amp;)
allocator::~allocator()
pointer allocator::address(reference x) const
const_pointer allocator::address(const_reference x) const
pointer allocator::allocate(size_type n , const void* = 0)
void allocator::deallocate(pointer p , size_type n)
size_type allocator::max_size() const
void allocator::construct(pointer p , const T&amp;amp; x)
void allocator::destroy(pointer p)&lt;/p&gt;
&lt;h2 id=&#34;iterator&#34;&gt;iterator&lt;/h2&gt;
&lt;p&gt;并不是所有的迭代器都是class type，如原生指针。如果不是class type，就无法为它定义内嵌型别。STL必须接受原生指针作为一种迭代器。
partial specialization（偏特化），如果class template拥有一个template参数，可以针对其中某个template参数进行特化工作，即可以再泛化设计中提供一个特化版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;该泛化版本允许T为任何型别
template&amp;lt;typename T&amp;gt;
class C {...};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;该版本适用于T为原生指针的情况，是上一个形式的进一步条件限制。
template&amp;lt;typename T&amp;gt;
class C&amp;lt;T*&amp;gt; {...};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设计一个class template专门用来萃取迭代器的特性，而value type 正是迭代器的特性之一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template &amp;lt;class I&amp;gt;
struct iterator_traits{
    typedef typename I::value_type value_type;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果I定义有自己的value_type，那么通过这个traits的作用，萃取出来的value_type是就是I::value_type
令iterator_traits拥有一个paritial sepcializations&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
struct iterator_traits&amp;lt;T*&amp;gt;{
    typedef T value_type;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据移动特性与施行操作，迭代器被分为五类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input iterator：这种迭代器所指的对象，不允许外接改变，只读。&lt;/li&gt;
&lt;li&gt;output iterator：唯写&lt;/li&gt;
&lt;li&gt;forward iterator：允许写入型算法(如replace())&lt;/li&gt;
&lt;li&gt;bidirectional iterator：可双向移动。某些算法需要逆向走访某个迭代器区间(例如逆向拷贝某范围内的元素)&lt;/li&gt;
&lt;li&gt;random access iterator：涵盖所有的指针算术能力
input iterator、output iterator -&amp;gt; forward iterator -&amp;gt; bidirectional iterator -&amp;gt; random access iterator。箭头代表概念与强化的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最常用的迭代器相应型别有五种：value_type、difference_type、pointer、reference、iterator_catagoly。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;value_type ，是指迭代器所指独享的型别。任何一个打算与STL算法有完美搭配的class，都应该定义自己的value type内嵌型别。&lt;/li&gt;
&lt;li&gt;difference_type，用来表示两个迭代器之间的距离，因此它可以用来表示一个容器的最大容量，对于一个连续空间的容器而言，头尾之间的距离就是其最大容量。如果一个一个泛型算法提供计数功能，如STL的count()，其返回值就得使用到difference_type。&lt;/li&gt;
&lt;li&gt;reference_type：
&lt;ul&gt;
&lt;li&gt;constant iterators，指不允许改变&amp;quot;所指对象的内容&amp;rdquo;，例如const int *pic;&lt;/li&gt;
&lt;li&gt;mutable iterators，指允许改变&amp;quot;所指对象的内容&amp;rdquo;，例如int * pi。&lt;/li&gt;
&lt;li&gt;对mutable iterators进行提领操作时，获得的不应该是一个右值，而是一个左值，因为右值不允许赋值操作，左值允许。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pointer_type
&lt;ul&gt;
&lt;li&gt;如果传递一个左值，令它代表p所指之物是可能的，那么传回一个左值，令它代表p所指之物的地址也可以。也就是说，传回一个pointer，指向迭代器所指之物。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;iterator_category&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>面试题</title>
      <link>https://wangwei9160.github.io/post/interview/</link>
      <pubDate>Thu, 25 Mar 2021 12:08:09 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/interview/</guid>
      
        <description>&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;编程语言&#34;&gt;编程语言&lt;/h3&gt;
&lt;h4 id=&#34;c和c的特点与区别&#34;&gt;c和c++的特点与区别&lt;/h4&gt;
&lt;p&gt;C语言：
1、面向过程的结构化语言，易于调试和维护。
2、表现能力和处理能力极强，可以直接访问内存的物理地址。
3、实现了对硬件的编程操作，也适合于应用软件开发。
4、效率高，可移植性强。
C++：
1、在C语言的基础上进行了扩充和完善，使C++兼容了C语言的面向过程的特点。
2、可以使用抽象数据类型进行基于对象的编程。
3、使用多继承、多态进行面向对象的编程。
4、以模板为特征的泛化编程。&lt;/p&gt;
&lt;h4 id=&#34;动态绑定&#34;&gt;动态绑定&lt;/h4&gt;
&lt;p&gt;函数的运行版本由实参决定，即在运行时选择函数的版本，叫动态绑定，主要通过虚函数表来实现。&lt;/p&gt;
&lt;h4 id=&#34;多态&#34;&gt;多态&lt;/h4&gt;
&lt;p&gt;静态多态：编译时多态，主要包括参数多态、过载多态和强制多态。
- 参数多态：采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。函数模板和类模板属于参数多态。参数多态又叫静态多态，执行速度快，异常少，调用在编译时已经确定。
- 过载多态：同一个名字在不同的上下文中代表的含义不同。典型的例子是运算符重载和函数重载。
- 强制多态：编译程序通过语义操作，把操作对象的类型强行改变，以符合函数或操作符的要求。例如int+double，就把int强制转换为double，然后执行double+double运算，实现了强制多态。
动态多态：运行时多态，包含多态的基础是虚函数，主要通过继承和虚函数来实现，当基类和子类拥有同名同参数同返回的方法，切该方法声明为虚函数，当基类对象，指针，引用指向的是派生类的对象的时候，基类对象，指针，引用在调用基类的方法，实际上调用的是派生类方法。
如果类中有虚方法，则自动在类中增加一个虚函数指针，该指针指向的是一个虚函数表，虚函数表中存在着每个虚函数真正对应的函数地址。动态多态采用一种延迟绑定技术，普通的函数调用，在编译期间就已经确定调用的函数的地址，所以无论如何调用都是对应的函数。如果是拥有虚函数的类，在调用虚函数时，首先去检查虚函数表，然后在确定调用的是哪一个函数，所以调用的函数是运行时绑定。&lt;/p&gt;
&lt;h4 id=&#34;多重继承和二义性&#34;&gt;多重继承和二义性&lt;/h4&gt;
&lt;p&gt;单继承：一个派生类的基类只有一个时称之为单继承。
多重继承：一个派生类的基类有两个或多个，派生类从两个或多个基类中继承所需的属性。
二义性：两个基类中的数据成员名相同，一般在标识符前使用基类名做前缀，借助于域运算符。
二义性发生的情况：
1、两个基类有同名成员：包括成员函数和成员数据。（解决方法：a.使用基类名来限定。例如c.A::a、c.A::display()。b.更清晰的表达:int A::a;int B::a;void A::display();void B::display)(）
2、基类和派生类有同名的成员。（规则：同名覆盖。基类的同名成员在派生类中被屏蔽，认为是&amp;quot;不可见的&amp;rdquo;，对于成员函数，只有函数名和参数个数相同、类型匹配的时候才是同名函数。如果只有函数名相同而参数不同只是重载。）
3、两个基类从同一个基类派生。（解决方法：虚基类。当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次。）&lt;/p&gt;
&lt;h4 id=&#34;volatile是做什么的使用实例&#34;&gt;volatile是做什么的，使用实例&lt;/h4&gt;
&lt;p&gt;volatile提醒编译器它后面定义的变量随时可能发生变化，因此编译后的程序在每次需要存储或者读取该变量时，都会直接从变量地址中读取数据。如果没有volatile关键字，程序可能会优化读取和存储，使用暂存在寄存器中的值。主要应用于设备的状态寄存器，中断服务子程序会访问到的非自动变量，多线程应用中被几个任务共享的变量。&lt;/p&gt;
&lt;h4 id=&#34;static-const的用法&#34;&gt;static const的用法&lt;/h4&gt;
&lt;h5 id=&#34;static&#34;&gt;static&lt;/h5&gt;
&lt;p&gt;static是修饰符，用来控制变量的存储方式和可见性。
基本用法：
1、在修饰变量的时候，static修饰的局部变量只执行一次初始化，而且延长了局部变量的生命周期，直到程序运行结束以后才会释放。
2、static修饰全局变量的时候，这个全局变量只在本文件中访问，不能在其他文件中访问。
3、static修饰一个函数，则这个函数只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动为0。
4、不想被释放的时候，可以使用static修饰。例如修饰在函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用static修饰。
5、数据安全性。当程序想要使用全局变量的时候应该先考虑static。
在类中的应用：
1、被static修饰的变量属于类变量，可以通过&lt;strong&gt;类名.变量名&lt;/strong&gt;直接引用，而不需要new出一个类来
2、被static修饰的方法属于类方法，可以通过&lt;strong&gt;类名.方法名&lt;/strong&gt;直接引用，而不需要new出一个类来。
被static修饰的变量和方法统一属于类的静态资源，是类实例之间共享的。静态成员是属于整个类的而不是某个对象，静态成员变量值存储一份供所有对象共用。所以在所有对象中都可以共享它，使用静态成员变量实现了多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。&lt;/p&gt;
&lt;h6 id=&#34;const&#34;&gt;const&lt;/h6&gt;
&lt;p&gt;const主要是防止定义的对象再次被修改，定义对象变量时要初始化变量。
基本用法：
1、用于定义常量变量，这个变量在后面就不可以被再次修改
2、保护传参时参数不被修改，如果使用引用传递参数或按地址传递参数给一个函数，在这个函数里这个参数的值若被修改，则函数外部传进来的变量的值也会发生改变，若想保护传进来的变量不被修改，可以使用const保护。
3、节约内存空间。const定义的变量，系统只为它分配一次内存，而使用#define定义的常量宏，能分配好多次，const能节约空间。
4、类中使用const修饰函数防止修改非static类成员变量。
5、修饰指针const int * p 、int const * p，const修饰指向的变量，p可变，p指向的对象不可变。int * const p，const修饰指针p，p不可变，p指向的对象可变。const int * const A ， 指针p和指针p指向的对象都不可变。
&lt;strong&gt;const位于 * 的左侧，则const就是用来修饰指针所指向的对象，即指针指向的对象是常量；如果const位于 * 的右侧，const就是修饰指针的本身，则指针本身是常量。&lt;/strong&gt;
6、修饰函数返回值，防止返回值被改变
7、修饰类的成员变量，使用const修饰的变量必须初始化，在类中不能再定义时初始化。在类的构造函数上初始化。初始化带static类型的变量，在类的外部初始化。
8、const定义的对象变量只能只作用于这个程序，不能被程序的其他文件调用。&lt;/p&gt;
&lt;h4 id=&#34;const-和-define&#34;&gt;const 和 define&lt;/h4&gt;
&lt;p&gt;define 只是一个常数的名字，在编译时编译器会把它替换成常数，仅仅是提升了代码的可读性。
const，是一个不能修改其值的变量，const定义的常量在内存中是有自己的地址的。&lt;/p&gt;
&lt;h4 id=&#34;类的const成员函数&#34;&gt;类的const成员函数&lt;/h4&gt;
&lt;p&gt;const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员。
非const成员函数可以访问非const对象的非const数据成员、const数据成员，不可以访问const对象的任意数据成员。
若成员函数并不对数据成员进行修改，应尽量声明为const成员函数。&lt;/p&gt;
&lt;h4 id=&#34;const-string-s-和-const-string-s的区别&#34;&gt;const string&amp;amp; s 和 const string s的区别&lt;/h4&gt;
&lt;p&gt;传参时，const string&amp;amp; s 比const string s更节约资源
值传递和引用传递方式的区别。
值传递，是从调用的地方把值复制一遍传给函数，需要形成实参的副本，有时间和空间的开销，如果是结构体或者类的话开销会更大，函数中对实参副本的修改并不会影响到函数调用位置实参的值。
引用传递，把实参的地址拷贝到形参，形参和实参共用一个内存地址，形参的修改会反映到实参上，32位中指针或者引用的开销只有4字节，开销小。
&amp;amp;的目的是引用，避免了复制，const是为了限定它是只读的。&lt;/p&gt;
&lt;h4 id=&#34;const-char-s--char-const-s-和-char--const-s的区别&#34;&gt;const char *s ， char const *s 和 char * const s的区别&lt;/h4&gt;
&lt;p&gt;const 关键字在类型或变量名之前是等价的。声明从右往左读。
char * const s，其中s是一个const指针 指向char类型，不可修改内容。
const char * s，其中s是一个指针 指向const char类型。
char const *s，由于没有没有const *的运算，所以const是修饰char的，与const char * s是一样的。&lt;/p&gt;
&lt;h4 id=&#34;类的静态数据成员&#34;&gt;类的静态数据成员&lt;/h4&gt;
&lt;p&gt;static关键字来把类的成员定义为静态的。无论有多少个类的对象，静态成员只有一个。静态成员在所有对象中是共享的。如果不存在其他初始化语句，在创建第一个对象时，所有静态数据都会被初始化为0，不能把静态成员的初始化放在类的定义中，可以再类的外面使用（::）来重新声明静态变量从而对它进行初始化。&lt;/p&gt;
&lt;h4 id=&#34;静态局部变量和局部变量&#34;&gt;静态局部变量和局部变量&lt;/h4&gt;
&lt;p&gt;静态变量都在全局数据区分配内存。静态局部变量在程序执行到该对象的声明出首次初始化，即以后的函数调用不再初始化。静态局部变量一般在声明处初始化，如果没有显式初始化，会被自动初始化为0。它始终驻留在全局数据区，知道程序运行结束，但是其作用域仅仅是局部作用域，当定义它的函数或语句结束之后，作用域随之结束。
局部变量的初始值不可知，作用域仅在它的函数或者语句内部，函数或语句结束之后，局部变量也将销毁。&lt;/p&gt;
&lt;h4 id=&#34;extern-c的作用&#34;&gt;extern C的作用&lt;/h4&gt;
&lt;p&gt;由于c语言不允许存在同名对象，而c++允许对一个名字基于不同的定义，只要在语义上没有二义性。如果工程中由多个源文件组成，在一个源文件中想引用另外一个源文件中已经定义的全局变量，只需要在引用变量的文件中用到extern关键字声明。&lt;/p&gt;
&lt;h4 id=&#34;指针-和-引用&#34;&gt;指针 和 引用&lt;/h4&gt;
&lt;p&gt;指针：对于一个类型T，T* 就是指向T的指针类型，也就是说一个T* 类型的变量能够保存一个T对象的地址。
引用：引用是一个对象的别名，主要用于函数参数和返回值类型，符号T&amp;amp;表示T类型的一个引用。
指针和引用的区别：
1、引用不可以为空，指针可以为空。引用是对象的别名，若引用为空则意味着对象不存在，所以定义一个引用的时候必须初始化。因此当一个变量用于指向另一个对象，如果它可能为空，则应该使用指针，如果不为空，则应该使用引用。
2、指针可以不指向任何对象，因此使用指针之前必须进行判空操作，而引用则不必。引用不可以改变指向，指针可以改变指向，指向其他独享。虽然引用不可以改变指向，但是可以改变初始化对象的内容。如++操作，对引用的操作直接反应到所指向的对象，而不改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。
3、引用的大小是所指向的变量的大小，指针是指针本身的大小，32位系统中是4个字节。
4、引用比指针更安全，不存在空引用，并且引用一旦被初始化为指向一个对象，就不能改变。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。&lt;/p&gt;
&lt;h4 id=&#34;静态内存分配和动态内存分配&#34;&gt;静态内存分配和动态内存分配&lt;/h4&gt;
&lt;p&gt;静态内存分配和动态内存分配区别：
1、时间不同。静态分配发生在程序编译和连接的时候，动态分配则发生在程序调入和执行的时候。
2、空间不同。堆是动态分配的，没有静态分配的。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配是由malloc函数进行分配的，栈的动态分配是编译器进行释放的，无需手动进行。&lt;/p&gt;
&lt;h4 id=&#34;new-和-malloc&#34;&gt;new 和 malloc&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;new/delete 是c++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。&lt;/li&gt;
&lt;li&gt;new操作返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，new是符合类型安全的操作。malloc内存分配成功返回的是void*，需要使用强制类型转换将void*指针转换成需要的类型。&lt;/li&gt;
&lt;li&gt;new内存分配失败返回的是bad_alloc异常。malloc内存分配失败返回的是null。&lt;/li&gt;
&lt;li&gt;c++允许重载new/delete操作符，new为对象调用构造函数来完成初始工作。而malloc不允许重载。&lt;/li&gt;
&lt;li&gt;new操作从自由存储区上为对象动态分配内存，而malloc函数从堆上动态分配内存。自由存储区是c++基于new操作符的一个抽象概念，凡是通过new进行内存申请，该内存就是自由存储区。而堆是操作系统的术语，是操作系统维护的一块特殊内存，用于程序的内存动态分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;malloc的实质&#34;&gt;malloc的实质&lt;/h4&gt;
&lt;p&gt;malloc函数有一个将可用的内存块连接为一个链表的空闲链表。调用malloc函数的时候，沿着链表寻找一个大小足以满足用户请求所需要的的内存块。然后将内存块一分为二（一块与用户请求的大小相等，另一块就是剩下的字节）。将分配给用户的内存传给用户，剩下的返回到链表上。调用free时，将用户释放的内存块连接到空闲链表上。到最后，空闲链表就会被切成很多小的内存片段。如果请求一个很大的内存片段，空闲链表上没有可以满足的片段，则malloc请求延时，将空闲链进行整理合并。如果依旧无法满足要求，则返回null。malloc内存不一定分配成功。&lt;/p&gt;
&lt;h4 id=&#34;内存泄漏&#34;&gt;内存泄漏&lt;/h4&gt;
&lt;p&gt;已动态分配的内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃等后果。&lt;/p&gt;
&lt;h5 id=&#34;智能指针&#34;&gt;智能指针&lt;/h5&gt;
&lt;p&gt;智能指针的行为与常规指针类似，重要的区别是它负责自动的释放所指向的对象。主要有两种智能指针：shared_ptr和unique_ptr。两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针共同指向同一个对象，只有当最后一个shared_ptr析构时，内存才会被释放。unique_ptr独占所指向的对象。还有weak_ptr是个弱引用，主要指向shared_ptr类型所指向的对象，不会改变shared_ptr的引用计数，即使有weak_ptr指向最后一个指对象的shared_ptr被销毁，对象还是会被释放。&lt;/p&gt;
&lt;h5 id=&#34;手写智能指针拷贝构造运算符&#34;&gt;手写智能指针，拷贝构造运算符&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
class my_shared_ptr{
    private:
        T* ptr = nullptr;
        int num = 0;
    public:
        my_shared_ptr() {};
        my_shared_ptr(nullptr) {};
        my_shared_ptr(T* ptr) : ptr(p) {num = 1};
        my_shared_ptr(const my_shared_ptr&amp;amp; p) : ptr(p.ptr) , num(p.num) {
            if(num) ++num;
        };
        my_shared_ptr(my_shared_ptr&amp;amp; p) {
            std::swap(ptr,p.ptr);
            std::swap(num,p.num);
        };
        ~my_shared_ptr() {
            if(num &amp;amp;&amp;amp; !(--num)){
                delete ptr;
                ptr = nullptr;
                num = 0;
            }
        }
        T* get(){
            return ptr;
        }
        int use_count(){
            return num;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;头文件中的ifndefdefineendif&#34;&gt;头文件中的ifndef/define/endif&lt;/h4&gt;
&lt;p&gt;防止头文件被重复包含和编译。头文件的重复包含会导致增大程序大小，重复编译增加编译时间。主要是防止一个源文件两次包含同一个头文件。
主要危害是：1、重复定义。2、无限编译
例如有test.cpp、a.h、b.h 其中test.cpp中include了a.h和b.h，a.h中include了b.h，而b.h中定义了一个变量b，则导致test.cpp中重复定义了变量b。&lt;/p&gt;
&lt;h4 id=&#34;预处理命令define定义一个常量用来表示一年中有多少秒&#34;&gt;预处理命令#define定义一个常量，用来表示一年中有多少秒&lt;/h4&gt;
&lt;p&gt;#define SECOND_PER_YEAR (60&lt;em&gt;60&lt;/em&gt;24*356)UL&lt;/p&gt;
&lt;h4 id=&#34;预处理器标识error&#34;&gt;预处理器标识#error&lt;/h4&gt;
&lt;p&gt;编译程序时，只要遇到#error就会跳出一个编译错误。主要目的是为了保证程序是按所想要的情况进行编译。
当不太确定是否定义了XX的时候，就可以使用#ifdef XXX #error &amp;ldquo;XXX has been defined&amp;rdquo; #else # endif。来提示宏XXX已经被定义了。&lt;/p&gt;
&lt;h4 id=&#34;struct-和-class&#34;&gt;struct 和 class&lt;/h4&gt;
&lt;p&gt;区别：
1、默认的继承访问权。class默认的是private，struct默认的是public
2、默认的访问权限。struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。
3、class还用于定义模板参数，像&amp;rsquo;typename&amp;rsquo;。struct不用于定义模板参数。
4、class和struct在大括号上的区别：
- class和struct如果定义了构造函数的话，都不能使用大括号进行初始化
- 如果没有定义构造函数，struct可以用大括号初始化。
- 如果没有定义构造函数，且所有成员变量全是public的话，class可以使用大括号初始化。
struct更适合看成一个数据结构的实现体，class更适合看成是一个对象的实现体。&lt;/p&gt;
&lt;h4 id=&#34;派生类-和-虚函数&#34;&gt;派生类 和 虚函数&lt;/h4&gt;
&lt;p&gt;派生类，必须通过使用类派生列表来明确指出它是从哪个基类继承而来的。类派生列表的形式是一个冒号后面紧跟以逗号隔开的基类列表。
虚函数，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于一些函数，基类希望它的派生类各自定义适合自身的版本。
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，也可以不添加，派生类可以显式地注明它将使用哪个成员函数改写基类的虚函数，且具体措施是在该函数的形参列表之后增加一个override关键字。&lt;/p&gt;
&lt;h4 id=&#34;虚函数和纯虚函数&#34;&gt;虚函数和纯虚函数&lt;/h4&gt;
&lt;p&gt;定义一个函数为虚函数是为了允许基类的指针来调用子类的函数，定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的必须实现这个函数。
纯虚函数：纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但是要求所有派生类都要定义自己的实现方法，在基类中实现纯虚函数的方法是在函数原型后面加上&amp;quot;=0&amp;rdquo;
纯虚函数的意义是让所有的类对象都可以执行纯虚函数的动作，但是类无法为纯虚函数提供一个合理的默认实现，所以类纯虚函数的生命就是在告诉子类的设计者，必须提供一个纯虚函数的实现，我不需要知道你是怎样实现它。&lt;/p&gt;
&lt;h4 id=&#34;虚函数表即其内存分配&#34;&gt;虚函数表即其内存分配&lt;/h4&gt;
&lt;p&gt;虚函数是通过一张虚函数表来实现的。在这个表中，主要是一个类的虚函数的地址表。若父类已经定义的virtual函数，当子类没有显示的重写(override)，则子类直接继承父类的虚函数实现，子类直接复制父类的虚表；当子类有显式的重写(virtual)，则会被当成对父类的改写，编译器会把该子类函数的地址放到该子类虚表中。编译器必须要保证虚函数表的指针存在于对象实例中最前面的位置。这意味着可以通过对象实例的地址得到这张虚函数表，然后遍历其中的函数指针，就可以调用相应的函数。
虚函数表位于只读数据段，即内存的常量区，而虚函数位于代码段，位于代码区。&lt;/p&gt;
&lt;h4 id=&#34;哪些不能是虚函数&#34;&gt;哪些不能是虚函数&lt;/h4&gt;
&lt;p&gt;1、**不支持普通函数作为虚函数。**普通函数只能被overload，不能被override，声明为虚函数也没有作用，编译器依旧在编译时绑定。
2、**不支持构造函数作为虚函数。**主要是考虑到语义上的问题。由于构造函数本来就是为了明确初始化对象成员才产生的，然后virtual function主要是为了在不了解细节的情况下也能正确处理对象。virtual函数是使不同类型的对象产生不同的动作，如果对象没有产生，如何使用virtual来完成想要的动作。a.构造函数不能被继承，因此不能被声明为virtual函数。b.构造函数一般是用来初始化对象，只有一个对象生成之后，才能发挥多态。
3、**不支持内联成员函数为虚函数。**内联函数主要为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承之后对象能准确执行自己的动作。inline函数在编译时被展开，而虚函数是在运行是才被动态绑定的。两者有着本质的区别。
4、**不支持静态成员函数为虚函数。**静态成员函数对于每个类来说都只有一份，所有的对象都共享这一份代码，没有进行动态绑定的必要，且不能被继承。
5、**不支持友元函数为虚函数。**不支持友元函数的继承，对于没有继承特性的函数就没有虚函数的说法。&lt;/p&gt;
&lt;h4 id=&#34;抽象类&#34;&gt;抽象类&lt;/h4&gt;
&lt;p&gt;抽象类是一种特殊的类，它是为了抽象和设计的目的建立的，它处于继承层次结构的较上层。
1、抽象类的定义：带有纯虚函数的类称为抽象类。
2、抽象类的作用：抽象类的主要作用是将有关的操作作为接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
3、使用抽象类注意事项：
- 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出，如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然是一个抽象类。如果实现了纯虚函数，就不再是抽象类，就可以建立对象了。
- 抽象类不能定义对象。&lt;/p&gt;
&lt;h4 id=&#34;派生新类的过程&#34;&gt;派生新类的过程&lt;/h4&gt;
&lt;p&gt;派生新类的过程一般要经历三个步骤:吸收基类成员、改造基类成员、添加新的成员。&lt;/p&gt;
&lt;h4 id=&#34;深拷贝和浅拷贝&#34;&gt;深拷贝和浅拷贝&lt;/h4&gt;
&lt;p&gt;编译器在我们没有定义拷贝构造函数的时候，会在拷贝对象时调用默认拷贝构造函数，进行的是浅拷贝。对指针进行拷贝之后会出现两个指针指向同一个内存空间。在对含有指针成员的对象进行拷贝的时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即深拷贝，这样就避免了内存泄漏。浅拷贝只是对指针的拷贝，深拷贝不仅对指针进行拷贝，还对指针指向的对象进行拷贝。浅拷贝带来的问题在于析构时多次释放内存，可以使用shared_ptr解决这个问题。&lt;/p&gt;
&lt;h4 id=&#34;静态关联动态关联&#34;&gt;静态关联、动态关联&lt;/h4&gt;
&lt;p&gt;在多态中，如果程序在编译阶段就能确定实际执行动作，就叫静态关联。如果等到程序运行时才能确定叫动态关联。&lt;/p&gt;
&lt;h4 id=&#34;重载&#34;&gt;重载&lt;/h4&gt;
&lt;p&gt;重载的作用：在同一个作用域内用同一个函数名命名一组功能相似的函数，减少了函数名的数量，避免了名字空间的污染。
函数重载是一种静态多态：多态是指用同一个东西表示不同的形态。函数重载是静态多态，即编译时多态。
编译器在编译.cpp文件中当前使用的作用域里的同名函数时，根据函数形参的类型和顺序会对函数进行重命名。C语言中编译器在编译.c文件时，指挥对函数进行简单的重命名，两个函数名相同的函数在编译之后也照样相同。调用时就不知道到底调用哪一个而出错。&lt;/p&gt;
&lt;h4 id=&#34;类型转换&#34;&gt;类型转换&lt;/h4&gt;
&lt;p&gt;1、static_cast：用于非多态类型的静态转换，对应于c中的隐式类型转换，但不能用于两个不想关类型的转换，例如整型和整型指针之间的转换。
2、reinterpret_cast：重新解释，可以将一种类型转换成另一种不相关类型，对于c中的强制类型转换，处理无法进行隐式转换的情况。
3、const_cast：功能是删除变量的const属性，方便再次赋值，该转换在编译时完成，用于解除const、volatile修饰符，只能转换指针或引用。
4、dynamic_cast：通常在基类和派生类之间转换使用。&lt;/p&gt;
&lt;h4 id=&#34;static_cast-而不用c语言的隐式转换&#34;&gt;static_cast 而不用c语言的隐式转换&lt;/h4&gt;
&lt;p&gt;c++中的static_cast转换的优势在于能在观看代码时就能够看出这个转换的底层含义或者潜在的风险，而c的转换则看上去是无差别的，不安全的。&lt;/p&gt;
&lt;h4 id=&#34;右值引用&#34;&gt;右值引用&lt;/h4&gt;
&lt;p&gt;通过&amp;rdquo; &amp;amp;&amp;amp; &amp;ldquo;而不是&amp;rdquo; &amp;amp; &amp;ldquo;来获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。可以自由地将一个右值引用的资源“移动”到另一个对象中。右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。右值引用主要运用于移动构造和移动赋值、转发。对于一个左值，一般会选择调用拷贝构造函数，这会造成资源的浪费，右值会在执行完之后就销毁，充分利用资源，右值是短暂的。&lt;/p&gt;
&lt;h4 id=&#34;进程通信&#34;&gt;进程通信&lt;/h4&gt;
&lt;h3 id=&#34;服务器编程&#34;&gt;服务器编程&lt;/h3&gt;
&lt;h3 id=&#34;网络编程&#34;&gt;网络编程&lt;/h3&gt;
&lt;h4 id=&#34;堆和栈&#34;&gt;堆和栈&lt;/h4&gt;
&lt;p&gt;堆：共有的空间，份全局堆和局部堆。全局堆是所有没有分配的空间，局部堆是用户分配的空间，堆在操作系统对进程初始化的时候分配，运行时也可以向操作系统索要额外的堆，但是用完得还给操作系统，否则就造成内存泄漏。
栈：栈是线程独有的，保存其运行状态和局部变量的。栈在线程开始的时候初始化，每个线程的栈相互独立，每个函数也有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，也就是切换SS/ESP寄存器。
堆空间不足：
栈空间不足：
栈空间存什么：函数的参数值，局部变量的值。
栈内存会被污染：定义一个变量，在修改另一个变量时，导致原油的变量值被修改，被称之为内存污染。栈是从高到低分配地址的，例如有char类型变量a,b，一个int类型指针指向了b所在的地址，给指针所在地址赋值为一个数时，a的地址比b的地址高，赋值会改变a所在地址的内容，造成内存污染。
谁会产生内存碎片：堆会产生内存碎片。
内存碎片怎么产生：malloc函数有一个将可用的内存块连接为一个链表的空闲链表。由于malloc分配时是沿着链表寻找一个大小足以满足用户请求所需的内存块，然后将内存块一分为二，将分配给用户的内存传给用户，剩下的则返回到链表上。调用free时，将用户释放的内存块连接到空闲链表上。到最后，空闲链表就会切成很多小的内存片段。如果请求一个很大的内存片段，空闲链表上没有可以满足的片段，则malloc请求延时，将空闲链进行整理合并。如果依旧无法满足要求，则返回null。malloc内存不一定分配成功。
如何预防内存碎片：1、伙伴算法，用于管理物理内存，避免内存碎片;伙伴系统是把所有的空闲页框分成11个块链表，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框。每个块的第一个页框的物理地址是该块大小的整数倍。假设要请求256个页框的块，步骤主要有两步。第一步，在256个页框的链表中检查是否有一个空闲块，如果没有，则查找下一个更大的块，如果有，则满足请求。第二步，在更大的块即512个页框的链表中检查是否有一个空闲块，如果有，把512个页框的空闲块分成两份，第一份用于满足请求，第二份链接到256个页框的链表中。如果没有空闲块，则继续查找更大的。2、高速缓存Slab层用于管理内核分配内存，避免碎片。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理方式不同：程序运行时，栈由操作系统自动分配管理，无须程序员人工控制，包括函数的参数值、返回值、局部变量等。而堆空间的申请、释放都是有程序员人工控制，也因此容易产生内存泄漏。&lt;/li&gt;
&lt;li&gt;空间大小不同：栈是向低位置扩展，是一块连续的内存区域。即栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将出现栈溢出的错误。而堆是向高地址扩展，是不连续的内存区域。因为系统是链表来存储空间内存地址的，且链表的遍历方向是由低地址向高地址扩展的&lt;/li&gt;
&lt;li&gt;产生的碎片：对于堆来说，频繁的malloc/free(new/delete)势必造成内存空间的不连续，从而造成大量的内存碎片，程序的运行效率低下。而对于栈来说，分配的一定是连续的内存空间。&lt;/li&gt;
&lt;li&gt;堆都是程序中由malloc/new函数动态申请分配的，有free/delete函数释放；而栈的分配和释放是由操作系统完成的。栈的动态分配有allocate()函数手动完成，但一般都无需手动操作，而是交给编译器自动进行申请和释放的。&lt;/li&gt;
&lt;li&gt;分配效率不同：堆的内存分配效率比栈低很多。因为栈有操作系统提供的，会在底层堆栈提供支持，分配专门的寄存器存放栈的地址，包括压栈出栈都由专门的指令执行，所以执行效率高。而堆是由c函数支持的，机制复杂，分配内存时库函数搜索可用的内存空间，如果没有足够的连续的空间，则需要操作系统来重新整理堆内存，这样才有机会分到足够大小的空间，然后返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;信号量&#34;&gt;信号量&lt;/h4&gt;
&lt;p&gt;信号量的作用：
信号量的同步：&lt;/p&gt;
&lt;h4 id=&#34;锁&#34;&gt;锁&lt;/h4&gt;
&lt;p&gt;mutex（互斥锁）、semaphore（信号量）、rw_semaphore（读写信号量）、spanblock（自旋锁）。
mutex：主要实现内核中的互斥访问功能，对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁，不能进行递归锁定或解锁。
semaphore：信号量创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，若初始值为1就变成互斥锁，一个任务想要访问共享资源，首先必须得到信号量，获取信号量的操作会将信号量的值减1，若当前信号量的值为负数，则表示无法获得信号量，若当前信号量的值为非负数，表示可以获得信号量。当任务访问完呗信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务正在等待当前信号量，因此它将被唤醒。
re_semaphore：读写信号量对访问者进行了细分，或是读者或是写者，读者在保持读写信号量期间只能对该信号量保护的共享资源进行读访问，如果一个任务除了读还需要写，就被归类为写者，它在对共享资源访问之前必须先获得写者身份，写者发现自己不需要写访问的情况下可以降级为读者。读写信号量同时拥有的读者数量不限。如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则读者必须被挂起知道写者释放信号量。
spanbloc：自旋锁与互斥锁有点类似，但不会引起调用者睡眠，如果自旋锁已经被别的执行单位保持，则调用者就一直循环在哪里看是否该自选这的保持者已经释放了锁，由于自旋锁使用者保持锁时间非常短，因此选择自选而不是睡眠，自旋锁的小绿远高于互斥锁。
锁的作用：实现对数据的保护。
锁的互斥：使用锁的目的是达到同步的作用，使共享资源在同一时间内，只有能有一个进程或者线程对他进行操作。&lt;/p&gt;
&lt;p&gt;管道及有名管道、信号、消息队列、共享内存、信号量、socket。&lt;/p&gt;
&lt;h4 id=&#34;多线程&#34;&gt;多线程&lt;/h4&gt;
&lt;p&gt;阻塞还是非阻塞：
是否可以传较大数据、最大多大：
消息队列最多缓存多少消息：
多线程数据同步问题：
多线程数据保护：&lt;/p&gt;
&lt;h4 id=&#34;线程间通信&#34;&gt;线程间通信&lt;/h4&gt;
&lt;p&gt;共享内存、消息传递、管道流
共享内存：线程之间共享程序的公共状态，线程之间通过读写内存中的公共状态来隐式通信。使用volatile共享内存
消息传递：线程之间没有公共的状态，线程之间必须明确的发送信息来显式的进行通信。wait/notify等待通知方式（最典型的是生产者-消费者模式）、join方式
管道流：管道输入/输出流的形式&lt;/p&gt;
&lt;h4 id=&#34;tcp-连接&#34;&gt;TCP 连接&lt;/h4&gt;
&lt;p&gt;建立一个TCP连接时会发生下述情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器必须准备好接受外来的连接。通过调用socket、bind和listen这3个函数来完成，称之为被动打开(passive open)&lt;/li&gt;
&lt;li&gt;客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据包只含有一个IP首部、一个TCP首部及可能有的TCP选项。&lt;/li&gt;
&lt;li&gt;服务器必须确认(ACK)客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。&lt;/li&gt;
&lt;li&gt;客户必须确认服务器的SYN。
这种交换至少需要3个分组，因此称之为三次握手。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;socket&#34;&gt;socket&lt;/h4&gt;
&lt;p&gt;client模型：
server模型：
server如何实现并发处理：
select：
select最大支持多少个fd：1024
socket有几个缓冲区：2个readbuf和writebuf
socket缓冲区如何设置：
UDP缓冲区满了，数据不会丢，为什么
TCP缓冲区满了，数据不会丢，为什么&lt;/p&gt;
&lt;h4 id=&#34;tcpip&#34;&gt;TCP/IP&lt;/h4&gt;
&lt;p&gt;TCP UDP 多播协议：
TCP协议的可靠性：
MTU是什么，默认多大：
UDP和多播数据格式的差异：&lt;/p&gt;
&lt;h4 id=&#34;红黑树&#34;&gt;红黑树&lt;/h4&gt;
</description>
      
    </item>
    
    <item>
      <title>Shell</title>
      <link>https://wangwei9160.github.io/post/shell/</link>
      <pubDate>Thu, 25 Mar 2021 10:35:51 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/shell/</guid>
      
        <description>&lt;h1 id=&#34;shell命令&#34;&gt;Shell命令&lt;/h1&gt;
&lt;h2 id=&#34;python和shell&#34;&gt;python和shell&lt;/h2&gt;
&lt;p&gt;shell更适合做批处理。shell需要各种命令工具支持。
python是通用语言。强扩展性，可读性更强。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you find you need to use arrays for anything more than assignment of ${PIPESTATUS}, you should use Python.&lt;/li&gt;
&lt;li&gt;If you are writing a script that is more than 100 lines long, you should probably be writing it in Python instead. Bear in mind that scripts grow. Rewrite your script in another language early to avoid a time-consuming rewrite at a later date.&lt;/li&gt;
&lt;li&gt;如果有复杂的对象，请使用python。&lt;/li&gt;
&lt;li&gt;如果写了超过100行的shell脚本，考虑使用python重写。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;shell脚本的基本写法&#34;&gt;shell脚本的基本写法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;脚本第一行，#! 指定解释器，例#!/bin/bash 表示以下内容使用bash解释器&lt;/li&gt;
&lt;li&gt;脚本第二部分，注释（#）说明，对脚本的基本信息进行描述&lt;/li&gt;
&lt;li&gt;脚本第三部分，脚本要实现的具体代码内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;shell脚本的执行方法&#34;&gt;shell脚本的执行方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;标准脚本执行方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1) 编写人生第一个shell脚本
# cat first_shell.sh

#!/bin/env bash

# 注释说明
# Name: first_shell.sh

echo &amp;quot;hello world&amp;quot;
echo &amp;quot;hello world&amp;quot;
echo &amp;quot;hello world&amp;quot;

2) 脚本增加可执行权限
# chmod +x first_shell.sh

3) 标准方式执行脚本
# pwd
/shell01
# /shell01/first_shell.sh
或者
# ./first_shell.sh

注意：标准执行方式脚本必须要有可执行权限。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;非标准执行方法
&lt;ul&gt;
&lt;li&gt;直接在命令行指定解释器执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# bash first_shell.sh
# sh first_shell.sh
# bash -x first_shell.sh
+ echo &#39;hello world&#39;
hello world
+ echo &#39;hello world&#39;
hello world
+ echo &#39;hello world&#39;
hello world
----------------
-x:一般用于排错，查看脚本的执行过程
-n:用来查看脚本的语法是否有问题
------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用source命令读取脚本文件，执行文件里的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# source first_shell.sh
hello world
hello world
hello world
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;p&gt;变量名=变量值&lt;/p&gt;
&lt;h4 id=&#34;变量名命名规则&#34;&gt;变量名命名规则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;区分大小写&lt;/li&gt;
&lt;li&gt;不能有特殊符号&lt;/li&gt;
&lt;li&gt;不能以数字开头&lt;/li&gt;
&lt;li&gt;等号两边不能有空格&lt;/li&gt;
&lt;li&gt;见名知意&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Template</title>
      <link>https://wangwei9160.github.io/post/template/</link>
      <pubDate>Tue, 23 Mar 2021 20:33:51 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/template/</guid>
      
        <description>&lt;h1 id=&#34;模块与泛型编程&#34;&gt;模块与泛型编程&lt;/h1&gt;
</description>
      
    </item>
    
    <item>
      <title>面向对象程序设计</title>
      <link>https://wangwei9160.github.io/post/oop/</link>
      <pubDate>Mon, 22 Mar 2021 23:00:56 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/oop/</guid>
      
        <description>&lt;h1 id=&#34;面向对象&#34;&gt;面向对象&lt;/h1&gt;
&lt;h2 id=&#34;oop&#34;&gt;OOP&lt;/h2&gt;
&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;
&lt;p&gt;通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个&lt;strong&gt;基类&lt;/strong&gt;，其他类则直接或间接地从基类继承而来，这些继承得到的类统称为&lt;strong&gt;派生类&lt;/strong&gt;。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数生命为&lt;strong&gt;虚函数&lt;/strong&gt;。
派生类必须通过使用&lt;strong&gt;类派生列表&lt;/strong&gt;明确指出它是从哪个基类继承而来的。类派生列表的形式是：一个冒号，后面紧跟以逗号分隔的基类列表。
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做。派生类可以显式地注明它将使用哪个成员函数改写基类的虚函数，且具体措施是在该函数的形参列表之后增加一个override关键字。&lt;/p&gt;
&lt;h4 id=&#34;函数调用的解析过程&#34;&gt;函数调用的解析过程&lt;/h4&gt;
&lt;p&gt;假定调用obj.mem()，则依次执行以下4个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先确定obj的静态类型。调用的是一个成员，所以该类型必须是类类型。&lt;/li&gt;
&lt;li&gt;在obj的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直到继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。&lt;/li&gt;
&lt;li&gt;一旦找到了mem，就进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法。&lt;/li&gt;
&lt;li&gt;假设调用合法，则编译器将根据是否是虚函数而产生不同的代码：
&lt;ul&gt;
&lt;li&gt;如果mem是虚函数且我们是通过引用或指针进行的拷贝，则编译器产生的代码将在运行时确定到底运行的是哪个版本，依据是对象的动态类型。&lt;/li&gt;
&lt;li&gt;反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用，则编译器将产生一个常规函数调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态绑定&#34;&gt;动态绑定&lt;/h3&gt;
&lt;p&gt;函数的运行版本由实参决定，即在运行时选择函数的版本，叫动态绑定又被称之为运动时绑定。
虚函数表实现。&lt;/p&gt;
&lt;h3 id=&#34;多态性&#34;&gt;多态性&lt;/h3&gt;
&lt;p&gt;具有继承关系的多个类型称为多态类型，使用这些类型的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型不同是多态性的体现。
当使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正作用的对象是什么类型，可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真是类型。
对非虚函数的调用在编译时进行绑定。通过对象进行的函数(虚函数或非虚函数)调用也在编译时绑定。对象的类型不是确定不变的，无论如何不能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。
&lt;strong&gt;当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;基类派生类&#34;&gt;基类派生类&lt;/h2&gt;
&lt;h3 id=&#34;基类&#34;&gt;基类&lt;/h3&gt;
&lt;p&gt;基类通常都需要定义一个虚析构函数，即使该函数不执行任何实际操作。&lt;/p&gt;
&lt;h4 id=&#34;成员函数与继承&#34;&gt;成员函数与继承&lt;/h4&gt;
&lt;p&gt;基类必须将它的两种成员函数区分开来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基类希望其派生类进行覆盖的函数；&lt;/li&gt;
&lt;li&gt;基类希望派生类直接继承而不要改变的函数。
对于牵着通常将其定义为&lt;strong&gt;虚函数&lt;/strong&gt;。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。
基类通过其成员函数的声明语句加上关键字&lt;strong&gt;virtual&lt;/strong&gt;使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在&lt;strong&gt;类内的声明语句之前&lt;/strong&gt;而不能用于类外部的函数定义。如果基类把一个函数声明称虚函数，则该函数在派生类中隐式地也是虚函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;访问控制与继承&#34;&gt;访问控制与继承&lt;/h4&gt;
&lt;p&gt;派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类派生而来的成员。和其他使用基类的代码一样，派生类能访问共有成员，而不能访问私有成员。基类中的&lt;strong&gt;protected访问运算符说明的成员&lt;/strong&gt;，希望它的派生类有权访问该成员，同时禁止其他用户访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友元关系不能传递，友元关系同样不能继承&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;默认的继承保护级别&#34;&gt;默认的继承保护级别&lt;/h5&gt;
&lt;p&gt;struct和class关键字定义的类具有不同的默认访问说明符。默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。&lt;strong&gt;唯一的差别就是默认成员访问说明符以及默认派生访问说明符。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;派生类&#34;&gt;派生类&lt;/h3&gt;
&lt;p&gt;派生类必须通过使用&lt;strong&gt;类派生列表&lt;/strong&gt;明确指出它是从哪个基类继承而来的。类派生列表的形式是：一个冒号，后面紧跟以逗号分隔的基类列表。&lt;/p&gt;
&lt;h4 id=&#34;派生类中的虚函数&#34;&gt;派生类中的虚函数&lt;/h4&gt;
&lt;p&gt;派生类有时覆盖它集成的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。
派生类可以(非必须)在它覆盖的函数前使用virtual关键字。c++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它集成的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。&lt;/p&gt;
&lt;h4 id=&#34;派生类对象及派生类向基类的类型转换&#34;&gt;派生类对象及派生类向基类的类型转换&lt;/h4&gt;
&lt;p&gt;因为在派生类对象中含有起基类对应的组成部分，所以能把派生类的对象当成基类对象来使用，而且能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常被称为&lt;strong&gt;派生类到基类的&lt;/strong&gt;类型转换。编译器会隐式地执行派生类到基类的转换。&lt;/p&gt;
&lt;h4 id=&#34;派生类构造函数&#34;&gt;派生类构造函数&lt;/h4&gt;
&lt;p&gt;尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;T3 ( int a , int b ) : T1(a),T2(b) {};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;派生类使用基类的成员&#34;&gt;派生类使用基类的成员&lt;/h4&gt;
&lt;p&gt;派生类可以访问基类的共有成员和受保护的成员。&lt;/p&gt;
&lt;h4 id=&#34;继承与静态函数&#34;&gt;继承与静态函数&lt;/h4&gt;
&lt;p&gt;如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。&lt;/p&gt;
&lt;h4 id=&#34;被用作基类的类&#34;&gt;被用作基类的类&lt;/h4&gt;
&lt;p&gt;如果想使用某个类作为基类，则该类必须被定义而非仅仅被声明。
如果不希望其他类继承它，或者不想考虑它是否适合作为一个基类。在类的后跟一个关键字&lt;strong&gt;final&lt;/strong&gt;，可以起到防止继承发生。&lt;/p&gt;
&lt;h2 id=&#34;虚函数&#34;&gt;虚函数&lt;/h2&gt;
&lt;p&gt;当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的一个。&lt;/p&gt;
&lt;h3 id=&#34;派生类中的虚函数-1&#34;&gt;派生类中的虚函数&lt;/h3&gt;
&lt;p&gt;一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样，派生类中的虚函数的返回类型也必须与基类函数匹配。该规则有一个&lt;strong&gt;例外&lt;/strong&gt;，当类的虚函数返回类型是类本身的指针或引用时，该规则无效。&lt;/p&gt;
&lt;h3 id=&#34;finaloverride&#34;&gt;final、override&lt;/h3&gt;
&lt;p&gt;派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这依然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数&lt;strong&gt;相互独立&lt;/strong&gt;。这时，派生类的函数并&lt;strong&gt;没有覆盖&lt;/strong&gt;基类中的版本。
在c++11新标准中可以使用override关键字来说明派生类中的虚函数。如果使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器讲报错。&lt;strong&gt;只有虚函数才能被覆盖&lt;/strong&gt;。
可以把某个函数指定为final，如果把函数定义为final，则之后任何尝试覆盖该函数的操作都将引发错误。&lt;/p&gt;
&lt;h3 id=&#34;回避虚函数的机制&#34;&gt;回避虚函数的机制&lt;/h3&gt;
&lt;p&gt;使用作用域运算符可以实现这一目的。强制调用某个版本的函数，而不管实际指向的对象到底是谁，该调用将在编译时完成解析。
&lt;strong&gt;通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制&lt;/strong&gt;。
通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要使用回避虚函数的默认机制。&lt;/p&gt;
&lt;h2 id=&#34;抽象基类&#34;&gt;抽象基类&lt;/h2&gt;
&lt;h3 id=&#34;纯虚函数&#34;&gt;纯虚函数&lt;/h3&gt;
&lt;p&gt;通过在函数体的位置(声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处。可以为纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说，不能在类的内部为一个=0的函数提供函数体。&lt;/p&gt;
&lt;h3 id=&#34;含有纯虚函数的类是抽象基类&#34;&gt;含有纯虚函数的类是抽象基类&lt;/h3&gt;
&lt;p&gt;含有(或者未经覆盖直接继承)纯虚函数的类是&lt;strong&gt;抽象基类&lt;/strong&gt;。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。不能(直接)创建一个抽象基类的对象。
&lt;strong&gt;不能创建抽象基类的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;派生类构造函数可以只初始化它的直接基类。&lt;/p&gt;
&lt;h2 id=&#34;构造函数与拷贝控制&#34;&gt;构造函数与拷贝控制&lt;/h2&gt;
&lt;h3 id=&#34;虚析构函数&#34;&gt;虚析构函数&lt;/h3&gt;
&lt;p&gt;继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样就可以动态分配继承体系中的对象。
当delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。析构函数的虚属性也会被继承。
&lt;strong&gt;一个基类总是需要析构函数，而且它能将析构函数设定为虚函数&lt;/strong&gt;。该析构函数为了成为虚函数而令内容为空，显然无法推断该基类还需要赋值运算符或拷贝构造函数。
&lt;strong&gt;虚析构函数将阻止合成移动操作&lt;/strong&gt;。如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。&lt;/p&gt;
&lt;h3 id=&#34;继承的构造函数&#34;&gt;继承的构造函数&lt;/h3&gt;
&lt;p&gt;派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，一个类也可以只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。
派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。
通常情况下，using声明语句只是令某个名字在其作用域内可见，而当作用域构造函数时，using声明语句将令编译器产生代码。对于基类的某个构造函数，编译器都生成一个与之对应的派生类构造函数。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>重载运算与类型转换</title>
      <link>https://wangwei9160.github.io/post/operator/</link>
      <pubDate>Mon, 22 Mar 2021 14:54:42 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/operator/</guid>
      
        <description>&lt;h1 id=&#34;重载运算与类型转换&#34;&gt;重载运算与类型转换&lt;/h1&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;关键字operator和其后要定义的运算符号共同组成。
运算符作用域内置类型的运算对象时，无法改变该运算符的含义。可以重载大部分（不是全部）的运算符。例如：&amp;rdquo; :: &amp;ldquo;、&amp;rdquo; .* &amp;ldquo;、&amp;rdquo; . &amp;ldquo;、&amp;rdquo; ? : &amp;quot; 都是不可以被重载的运算符。
以下两次调用是等价的，都调用了非成员函数operator+：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;oprd1 + oprd2 ;
operator+(oprd1 , oprd2);
由于重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法引用到重载的运算符上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;选择将运算符定义为成员函数或非成员函数&#34;&gt;选择将运算符定义为成员函数或非成员函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;赋值(=)、下标(&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; )、调用( ( ) )和成员访问箭头( -&amp;gt; )运算符必须是成员。&lt;/li&gt;
&lt;li&gt;复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。&lt;/li&gt;
&lt;li&gt;改变对象状态的运算符或者给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。&lt;/li&gt;
&lt;li&gt;具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;输入和输出运算符&#34;&gt;输入和输出运算符&lt;/h2&gt;
&lt;h3 id=&#34;重载输出运算符&#34;&gt;重载输出运算符&amp;laquo;&lt;/h3&gt;
&lt;p&gt;通常情况下，输出运算符的&lt;strong&gt;第一个形参&lt;/strong&gt;是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。&lt;strong&gt;第二个参数&lt;/strong&gt;一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是希望避免复制实参，且打印对象不会改变对象的内容。&lt;/p&gt;
&lt;h4 id=&#34;输出运算符尽量减少格式化操作&#34;&gt;输出运算符尽量减少格式化操作&lt;/h4&gt;
&lt;p&gt;用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符打印了换行符，则用户就无法在对象的同一行内接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。
通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与iostream标准库兼容的输入输出运算符必须是普通的而非成员函数，而不能是类的成员函数。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;重载输入运算符&#34;&gt;重载输入运算符&amp;raquo;&lt;/h3&gt;
&lt;p&gt;通常情况下，输入运算符的&lt;strong&gt;第一个形参&lt;/strong&gt;是运算符将要读取的流的引用，&lt;strong&gt;第二个形参&lt;/strong&gt;是将要读入到(非常量)对象的引用。该运算符通常会返回给某个给定流的引用。第二个心颤必须是非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。
&lt;strong&gt;当读取操作发生错误时，输入运算符应该负责从错误中恢复。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;算术和关系运算符&#34;&gt;算术和关系运算符&lt;/h2&gt;
&lt;p&gt;通常情况下，把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量引用。&lt;/p&gt;
&lt;h3 id=&#34;相等运算符&#34;&gt;相等运算符&lt;/h3&gt;
&lt;p&gt;通常情况下，c++的类通过定义相等运算符来检验两个对象是否相等。会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。&lt;/p&gt;
&lt;h3 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;通常情况下，关系运算符应该：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义顺序关系，令其余关联容器中对关键字的要求一致；&lt;/li&gt;
&lt;li&gt;如果类同时也含有== 运算符的话，则定义一种关系令其与== 保持一致。特别是如果两个对象是!=的，那么一个对象应该&amp;lt;另外一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;赋值运算符&#34;&gt;赋值运算符&lt;/h3&gt;
&lt;p&gt;拷贝赋值和移动赋值运算符，可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。&lt;/p&gt;
&lt;h3 id=&#34;下标运算符&#34;&gt;下标运算符&lt;/h3&gt;
&lt;p&gt;表示容器的类通常可以通过元素在容器中的位置访问元素，这些类会定义下标运算符operator[ ]。&lt;/p&gt;
&lt;h3 id=&#34;递增和递减运算符&#34;&gt;递增和递减运算符&lt;/h3&gt;
&lt;p&gt;在迭代器类中通常会实现递增(++)和递减(&amp;ndash;)运算符。这两种运算符使得类可以再元素的序列中前后移动。&lt;/p&gt;
&lt;h4 id=&#34;区分前置和后置运算符&#34;&gt;区分前置和后置运算符&lt;/h4&gt;
&lt;p&gt;由于前置和后置版本使用的是同一个符号，意味着起重载版本所用的名字是相同的，并且运算对象的数量和类型都是相同的。为了解决这个问题，后置版本接受一个额外的(不被使用的) int类型的形参。&lt;/p&gt;
&lt;h4 id=&#34;显式地调用后置运算符&#34;&gt;显式地调用后置运算符&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;obj.operator++(0);//调用后置版本的operator++
obj.operator++(); //调用前置版本的opeator++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;成员访问运算符&#34;&gt;成员访问运算符&lt;/h3&gt;
&lt;p&gt;在迭代器类以及智能指针类中常常用到解引用运算符(*)和箭头运算符(-&amp;gt;)。&lt;/p&gt;
&lt;h3 id=&#34;函数调用运算符&#34;&gt;函数调用运算符&lt;/h3&gt;
&lt;p&gt;如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象。&lt;/p&gt;
&lt;h4 id=&#34;lambda是函数对象&#34;&gt;lambda是函数对象&lt;/h4&gt;
&lt;p&gt;编写一个lambda，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符。其行为类似于产生一个类的未命名对象，产生的类只有一个函数调用运算符成员。它的形参列表和函数体与lambda表达式完全一样。&lt;/p&gt;
&lt;h2 id=&#34;重载类型转换与运算符&#34;&gt;重载、类型转换与运算符&lt;/h2&gt;
&lt;p&gt;由一个实参调用的非显式构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了&lt;strong&gt;类类型转换&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;类型转换运算符&#34;&gt;类型转换运算符&lt;/h4&gt;
&lt;p&gt;类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;operator type() const;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;避免有二义性的类型转换&#34;&gt;避免有二义性的类型转换&lt;/h4&gt;
&lt;p&gt;如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。
两种情况下可能产生多重转换路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个类提供了相同的类型转换。例如，A类定义了一个接受B类对象的转换构造函数吗，同时B类定义了一个转换目标是A类的类型转换运算符时，它们提供了相同的类型转换。&lt;/li&gt;
&lt;li&gt;类定义了多个转换规则，这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对于某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://wangwei9160.github.io/post/thread/</link>
      <pubDate>Sun, 21 Mar 2021 14:00:09 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/thread/</guid>
      
        <description>&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合的&lt;strong&gt;一次运行过程&lt;/strong&gt;，是系统进行&lt;strong&gt;资源分配和调度&lt;/strong&gt;的一个独立单位。&lt;/p&gt;
&lt;h5 id=&#34;进程一般具有&#34;&gt;进程一般具有：&lt;/h5&gt;
&lt;p&gt;动态性、并发性、独立性、异步性。&lt;/p&gt;
&lt;h5 id=&#34;进程的状态&#34;&gt;进程的状态：&lt;/h5&gt;
&lt;p&gt;就绪状态、运行状态、阻塞状态、创建状态、终止状态。&lt;/p&gt;
&lt;h5 id=&#34;经典进程同步问题&#34;&gt;经典进程同步问题：&lt;/h5&gt;
&lt;p&gt;生产者-消费者问题、哲学家进餐问题、读者-写者问题、理发师问题。&lt;/p&gt;
&lt;h5 id=&#34;进程调度算法&#34;&gt;进程调度算法：&lt;/h5&gt;
&lt;p&gt;先来先服务(FCFS)、短作业优先(SJF)、高响应比优先、优先级、时间片轮转、多级队列、多级反馈队列调度算法。&lt;/p&gt;
&lt;h5 id=&#34;进程通信&#34;&gt;进程通信：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;共享存储器系统通信(共享内存)、消息传递系统通信、管道通信(无名管道、有名管道)、客户-服务器系统通信(socket)、消息缓冲队列通信机制。&lt;/li&gt;
&lt;li&gt;或&lt;/li&gt;
&lt;li&gt;管道及有名管道、信号、消息队列、共享内存、信号量、socket。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;通信方式的优缺点&#34;&gt;通信方式的优缺点：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;管道：速度慢，容量有限，且只有父子进程之间才能通信&lt;/li&gt;
&lt;li&gt;消息队列：容量受到系统限制，且在第一次读的时候，还要考虑上一次没有读完的数据&lt;/li&gt;
&lt;li&gt;信号量：不能传递复杂消息，只能用来同步。&lt;/li&gt;
&lt;li&gt;共享内存区：能够容易控制容量，速度快，但是要保持同步，注意其中一个写的时候，另一个进程读写的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;进程死锁&#34;&gt;进程死锁：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;产生死锁的原因：
&lt;ul&gt;
&lt;li&gt;竞争资源&lt;/li&gt;
&lt;li&gt;进程推进顺序不当&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;产生死锁的必要条件：
&lt;ul&gt;
&lt;li&gt;互斥条件&lt;/li&gt;
&lt;li&gt;占有且等待条件&lt;/li&gt;
&lt;li&gt;不可剥夺条件&lt;/li&gt;
&lt;li&gt;循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理死锁的基本方法：
&lt;ul&gt;
&lt;li&gt;预防死锁&lt;/li&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;检测和接触死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预防死锁：
&lt;ul&gt;
&lt;li&gt;破坏占有且等待条件&lt;/li&gt;
&lt;li&gt;破坏不可剥夺条件&lt;/li&gt;
&lt;li&gt;破坏循环等待条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;p&gt;线程是进程中的一个可调度实体，是&lt;strong&gt;cpu调度和分配&lt;/strong&gt;的基本单位。&lt;/p&gt;
&lt;h5 id=&#34;线程的状态&#34;&gt;线程的状态：&lt;/h5&gt;
&lt;p&gt;就绪状态、运行状态、阻塞状态、创建状态、终止状态。&lt;/p&gt;
&lt;h5 id=&#34;线程通信的方式&#34;&gt;线程通信的方式&lt;/h5&gt;
&lt;p&gt;共享内存、消息传递、管道流
共享内存：线程之间共享程序的公共状态，线程之间通过读写内存中的公共状态来隐式通信。使用volatile共享内存
消息传递：线程之间没有公共的状态，线程之间必须明确的发送信息来显式的进行通信。wait/notify等待通知方式、join方式
管道流：管道输入/输出流的形式&lt;/p&gt;
&lt;h3 id=&#34;线程和进程的关系&#34;&gt;线程和进程的关系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进程至少有一个线程，通常将此线程称为主线程。&lt;/li&gt;
&lt;li&gt;资源分配给进程，同一进程的所有线程共享该进程的所有资源。&lt;/li&gt;
&lt;li&gt;真正在处理机上运行的是线程。
多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>网络编程</title>
      <link>https://wangwei9160.github.io/post/socket/</link>
      <pubDate>Sat, 20 Mar 2021 10:46:16 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/socket/</guid>
      
        <description>&lt;h1 id=&#34;网络编程&#34;&gt;网络编程&lt;/h1&gt;
&lt;h2 id=&#34;tcpip协议&#34;&gt;TCP/IP协议&lt;/h2&gt;
&lt;p&gt;应用层、运输层(tcp/udp)、网络层(ip)、网络接口层。&lt;/p&gt;
&lt;h2 id=&#34;运输层&#34;&gt;运输层&lt;/h2&gt;
&lt;p&gt;主要包含两种协议：
传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。&lt;/p&gt;
&lt;h3 id=&#34;协议&#34;&gt;协议&lt;/h3&gt;
&lt;h4 id=&#34;运行在tcp协议上的协议&#34;&gt;运行在TCP协议上的协议：&lt;/h4&gt;
&lt;p&gt;HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
FTP（File Transfer Protocol，文件传输协议），用于文件传输。
POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。&lt;/p&gt;
&lt;h4 id=&#34;运行在udp协议上的协议&#34;&gt;运行在UDP协议上的协议：&lt;/h4&gt;
&lt;p&gt;BOOTP（Boot Protocol，启动协议），应用于无盘设备。
NTP（Network Time Protocol，网络时间协议），用于网络同步。
DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。&lt;/p&gt;
&lt;h5 id=&#34;运行在tcp和udp协议上&#34;&gt;运行在TCP和UDP协议上：&lt;/h5&gt;
&lt;p&gt;DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。&lt;/p&gt;
&lt;h2 id=&#34;阻塞非阻塞同步异步&#34;&gt;阻塞、非阻塞、同步、异步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阻塞/非阻塞&lt;/strong&gt;关注的是&lt;strong&gt;程序在等待调用结果&lt;/strong&gt;时的状态。阻塞是等待。非阻塞是不需要等待。例如：
&lt;ul&gt;
&lt;li&gt;去书店问老板有没有xx书。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞&lt;/strong&gt;会将自己&amp;quot;挂起&amp;rdquo;，直到得到老板回应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非阻塞&lt;/strong&gt;则会不管老板有没有回应，先弄自己的，偶尔check一下老板有没有回应。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步/异步&lt;/strong&gt;关注的是&lt;strong&gt;消息通信机制&lt;/strong&gt;。同步是主动等待数据。异步是被动接受数据，被调用者通过&amp;quot;状态&amp;rdquo;、&amp;ldquo;通知&amp;rdquo;、&amp;ldquo;回调&amp;quot;三种途径通知调用者。
&lt;ul&gt;
&lt;li&gt;打电话问书店老板有没有xx书。&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;同步&lt;/strong&gt;机制，书店老板说我查一下，然后开始等待老板查询结果，当老板告诉结果时，才会返回结果（返回）。&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;异步&lt;/strong&gt;机制，老板则是说我查一下查完告诉你结果，就挂掉电话（返回没有结果），当老板查好后通过回电的方式告诉结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io模型&#34;&gt;IO模型&lt;/h2&gt;
&lt;p&gt;IO的五种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞IO&lt;/li&gt;
&lt;li&gt;非阻塞IO&lt;/li&gt;
&lt;li&gt;IO多路复用&lt;/li&gt;
&lt;li&gt;信号驱动IO&lt;/li&gt;
&lt;li&gt;异步IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以去书店买书，然而书店没有书为例。
1、阻塞IO
一直在书店等待，直到书店有书，这是&lt;strong&gt;同步阻塞IO&lt;/strong&gt;
2、非阻塞IO
隔一段时间去书店看看有没有书，这是&lt;strong&gt;同步非阻塞IO&lt;/strong&gt;
3、IO多路复用
整个事件只有在select、poll、epoll这些调用的时候才会阻塞，收发客户信息不会阻塞。
来书店买书的时候，书店有一排的书，并不知道哪个书架上有书，老板告诉去哪里找书，这是&lt;strong&gt;IO多路复用&lt;/strong&gt;
4、信号驱动IO
老板在书店有书的时候告诉有书，这是&lt;strong&gt;信号驱动IO&lt;/strong&gt;
5、异步IO
老板在书店有书的时候直接寄到家里，这是&lt;strong&gt;异步IO&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;io复用模型selectpollepoll&#34;&gt;IO复用模型select、poll、epoll&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;select：
&lt;ul&gt;
&lt;li&gt;每一次调用，都需要将fd(file descriptor)集合从用户态拷贝到内核态，若fd数量很大，将会造成很大的开销。&lt;/li&gt;
&lt;li&gt;每一次调用，都需要在内核遍历所有传递进来的fd集合，若fd集合数量很大，将会造成很大的开销&lt;/li&gt;
&lt;li&gt;select最多监听1024个描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;poll：本质上和select没有区别，没有最大连接的限制，基于链表来存储
&lt;ul&gt;
&lt;li&gt;将用户传入的数组拷贝到内核空间，查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并进行遍历，如果遍历完所有fd没有发现就绪设备，则挂起，知道设备就绪或者主动超时，被唤醒后继续遍历，该过程经历了许多无用的遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;epoll：相比于select和poll，epoll没有描述符限制。
&lt;ul&gt;
&lt;li&gt;没有最大并发连接的限制。&lt;/li&gt;
&lt;li&gt;只管活跃可用的fd，而跟连接总数无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ltet&#34;&gt;LT、ET&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LT(level triggered)是缺省的工作方式，&lt;strong&gt;只要缓冲区有数据就会触发&lt;/strong&gt;，支持block和no-block socket。
&lt;ul&gt;
&lt;li&gt;优点：缓冲区有数据内核就会一直通知，保证了数据的完整性。&lt;/li&gt;
&lt;li&gt;缺点：只要缓冲区有数据内核就会一直通知，导致内核频繁切换到用户态，内核效率低下。&lt;/li&gt;
&lt;li&gt;select和poll都是LT。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ET(Edge triggered)是&lt;strong&gt;高速工作模式，只有数据到来才触发，不管原缓冲区是否还有数据&lt;/strong&gt;，只支持no-block socket。
&lt;ul&gt;
&lt;li&gt;优点：内核只为就绪的描述符发送一次通知，减少了内核的资源浪费。&lt;/li&gt;
&lt;li&gt;缺点：缓冲区可能有数据剩余。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reactor模型&#34;&gt;Reactor模型&lt;/h2&gt;
&lt;p&gt;对于支持多连接的服务器，一般总结为2种fd和3种事件。&lt;/p&gt;
&lt;h5 id=&#34;2种fd&#34;&gt;2种fd：&lt;/h5&gt;
&lt;p&gt;1、listenfd：一般情况下，只有一个。用来监听特定的端口(如80)。
2、connfd：每个连接都有一个connfd。用来收发数据。&lt;/p&gt;
&lt;h5 id=&#34;3种事件&#34;&gt;3种事件：&lt;/h5&gt;
&lt;p&gt;1、listenfd进行accept阻塞监听，创建一个connfd。
2、用户态/内核态copy数据。每个connfd对应着2个应用缓冲区，readbuf和writebuf。
3、处理connfd发来的数据。业务逻辑处理，准备response到writebuf。&lt;/p&gt;
&lt;p&gt;Reactor模型基于事件驱动，特别适合处理海量的I/O事件。
Reactor模型中定义的三种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reactor：负责监听和分配事件，将I/O事件分配给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。&lt;/li&gt;
&lt;li&gt;Acceptor：处理客户端新连接，并分派请求到处理器链中。&lt;/li&gt;
&lt;li&gt;Handler：将自身与事件绑定，执行非阻塞读/写人物，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reatcor处理请求的流程：
读取操作：
1、应用程序注册读就绪事件和相关联的时间处理器
2、事件分离器等待时间的发生
3、当发生读就绪事件的时候，时间分离器调用第一步注册的事件处理器。
写入操作类似于读取操作，第一步是写就绪事件。&lt;/p&gt;
&lt;h4 id=&#34;单reactor单线程模型&#34;&gt;单Reactor单线程模型&lt;/h4&gt;
&lt;p&gt;Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler，Redis使用Reactor单进程的模型。&lt;/p&gt;
&lt;p&gt;消息处理流程：
1、Reactor对象通过select监控连接事件，收到事件后通过dispatch进行转发。
2、如果是连接建立的事件，则由acceptor接受连接，并创建handler处理后续事件。
3、如果不是建立连接事件，则Reactor会分发调用Handler来响应。
4、Handler会完成read-&amp;gt;业务处理-&amp;gt;send的完整业务流程。&lt;/p&gt;
&lt;p&gt;单Reactor单线程模型可以应用于一些小容量应用场景，但是对于高负载、大并发的应用场景却不合适，主要原因：
1、即使Reactor线程的CPU负载达到100%，也无法满足海量消息的编码、解码、读取和发送。
2、当Reactor线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后重发，更加重Reactor线程的负载，最终会导致大量消息挤压和处理超时。
3、一旦Reactor线程意外中断或者进入死循环，会导致整个系统通信模块不可用，不能接受和处理外部消息。&lt;/p&gt;
&lt;h4 id=&#34;单reactor多线程模型&#34;&gt;单Reactor多线程模型&lt;/h4&gt;
&lt;p&gt;该模型在事件处理器（Handler）部分采用了多线程（线程池）。&lt;/p&gt;
&lt;p&gt;消息处理流程：
1、Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发。
2、如果是建立连接请求事件，则由acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后续各种事件。
3、如果不是建立连接请求事件，则Reactor会分发调用连接对应的Handler来响应。
4、Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理。
5、Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理。
6、Handler收到响应结果后通过send将相应结果返回给Client。&lt;/p&gt;
&lt;p&gt;这个模型存在的问题：
1、多线程数据共享和访问比较复杂，涉及到共享数据的互斥和保护机制。
2、Reactor承担所有时间的监听和响应，只在主线程中运行，可能存在性能问题。&lt;/p&gt;
&lt;h4 id=&#34;主从reactor多线程模型&#34;&gt;主从Reactor多线程模型&lt;/h4&gt;
&lt;p&gt;将Reactor分成两部分：
1、mainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socket channel指定注册给subReactor
2、subReactor主要做和建立起来的socket做数据交互和事件业务处理操作。通常，subReactor个数上可与CPU个数等同。&lt;/p&gt;
&lt;p&gt;消息处理流程：
1、从主线程池中随机选择一个Reactor线程作为acceptor线程，用于绑定监听端口，接受客户端连接。
2、acceptor线程接受客户端连接请求之后创建新的socket channel，将其注册到主线程池的其他Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作。
3、步骤2完成后，业务层的链路正式连接，将socket channel从主线程池的Reactor线程的多路复用器摘除，重新注册到sub线程池的线程上，并创建一个Handler用于处理各种连接事件。
4、当有新的事件发生时，subReactor会调用连接对应的Handler进行相应。
5、Handler通过Read读取数据后，会分发给后面的Worker线程池进行业务处理。
6、Worker线程池会分配独立的线程完成真正的业务处理，如何将相应结果发送给Handler进行处理。
7、Handler收到响应结果后通过send将响应结果返回给Client&lt;/p&gt;
&lt;h4 id=&#34;keepalive&#34;&gt;keepalive&lt;/h4&gt;
&lt;p&gt;Keepalive是TCP中一个检测死连接的心跳包保活机制，原理就是TCP在闲了一段时间后会发送数据给对方。
1、如果对端会发送ACK，那么就认为对端是存活的。
2、如果对端就会发送RST包，那么TCP就会撤销该连接。
3、如果对端不发送ACK、RST，那么TCP在一段超时重传之后自动撤销连接。&lt;/p&gt;
&lt;p&gt;RST：重置连接、复位连接，用来关闭异常的连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么时候发送RST包
&lt;ul&gt;
&lt;li&gt;建立连接的SYN到达某端口，但是该端口上没有正在监听的服务。&lt;/li&gt;
&lt;li&gt;TCP收到了一个根本不存在的连接上的分节。&lt;/li&gt;
&lt;li&gt;请求超时。 接收数据超时时，会发送RST包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三次握手&#34;&gt;三次握手&lt;/h3&gt;
&lt;p&gt;建立一个TCP连接时会发生下述情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器必须准备好接受外来的连接。通过调用socket、bind和listen这3个函数来完成，称之为被动打开(passive open)&lt;/li&gt;
&lt;li&gt;客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据包只含有一个IP首部、一个TCP首部及可能有的TCP选项。&lt;/li&gt;
&lt;li&gt;服务器必须确认(ACK)客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。&lt;/li&gt;
&lt;li&gt;客户必须确认服务器的SYN。
这种交换至少需要3个分组，因此称之为三次握手。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四次握手&#34;&gt;四次握手&lt;/h3&gt;
&lt;p&gt;建立一个SCTP关联的时候回发生下述情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器必须准备好接受外来的连接。通过调用socket、bind和listen这3个函数来完成，称之为被动打开(passive open)&lt;/li&gt;
&lt;li&gt;客户通过调用connect或者发送一个隐式打开该关联的消息进行主动打开。这使得用户SCTP发送一个INIT消息(初始化)，该消息告诉服务器客户的IP清单、初始序列号、用于标识本关联中所有分组的起始标记、客户请求的外出流的数目以及客户能够支持外来的流的数目&lt;/li&gt;
&lt;li&gt;服务器以一个INIT ACK消息确认客户的INIT消息，其中含有服务器的IP清单、初始序列号、起始标记、服务器请求的外出流的数目、服务器能够支持的外来流的数目以及一个状态cookie。状态cookie包含服务器用于确信本关联有效所需的所有状态，它是数字化签名过的，以确保其有效性。&lt;/li&gt;
&lt;li&gt;客户以一个COOKIE ECHO消息回射服务器的状态cookie。除COOKIE ECHO外，该消息可能在同一个分组中还捆绑了用户数据。&lt;/li&gt;
&lt;li&gt;服务器以一个COOKIE ACK消息确认客户回射的cookie正确，本关联于是确立。该消息也可能在同一分组中还捆绑了用户数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h3&gt;
&lt;p&gt;TCP终止一个连接需要4个分节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个应用进程首先调用close，称该端执行主动关闭(active close)。该端的TCP于是发送一个FIN分节，表示数据发送完毕。&lt;/li&gt;
&lt;li&gt;接收到这个FIN的对端执行被动关闭(passive close)。这个FIN由TCP确认，它的接收也作为一个文件结束符(end_of_file)传递给接收端应用进程(放在已排队等候该应用进程接收的任何其他数据之后)，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。&lt;/li&gt;
&lt;li&gt;一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的socket。这导致它的TCP也发送一个FIN。&lt;/li&gt;
&lt;li&gt;执行这个最终FIN的原发送端TCP(执行主动关闭的那一端)确认这个FIN。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sctp关联终止&#34;&gt;SCTP关联终止&lt;/h3&gt;
&lt;p&gt;SCTP 当一端关闭某个关联时，另一端必须停止发送新的数据。关联关闭请求的接收端发送完已经排队的数据(如果有的话)后，完成关联的关闭。&lt;/p&gt;
&lt;h3 id=&#34;端口号&#34;&gt;端口号&lt;/h3&gt;
&lt;p&gt;16位整数的端口号
支持FTP的任何TCP/IP实现都把21端口分配给FTP服务器。分配给简化文件传送协议(TFTP)的是UDP端口号69。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;众所周知的端口为0~1023&lt;/li&gt;
&lt;li&gt;已登记的端口为1024~49151&lt;/li&gt;
&lt;li&gt;动态或私用的端口为49152~65535&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;连接建立终止时交换的报文&#34;&gt;连接建立/终止时交换的报文&lt;/h3&gt;
&lt;p&gt;当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。&lt;/p&gt;
&lt;h3 id=&#34;tcp报文&#34;&gt;TCP报文&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;源端口：占16位，源端口号。&lt;/li&gt;
&lt;li&gt;目标端口：占16位，目的端口号。&lt;/li&gt;
&lt;li&gt;序号：seq序号，占32位，用来标识从TCP端向目的端发送的字节流，发送方发送数据时对此进行标记。&lt;/li&gt;
&lt;li&gt;确认序号：ack序号，占32位，只有ACK标识为1时，确认序号字段才有效，确认方ack = 发送方seq + 1.&lt;/li&gt;
&lt;li&gt;报文首部长度：占4位，TCP首部长度。&lt;/li&gt;
&lt;li&gt;标志位：共6个，URG、ACK、PSH、RST、SYN、PIN。
&lt;ul&gt;
&lt;li&gt;ACK：确认序号有效&lt;/li&gt;
&lt;li&gt;FIN：释放连接&lt;/li&gt;
&lt;li&gt;PSH：接收方应该尽快将报文交给应用层&lt;/li&gt;
&lt;li&gt;RST：重新连接&lt;/li&gt;
&lt;li&gt;SYN：发送一个新连接&lt;/li&gt;
&lt;li&gt;URG：紧急指针有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;窗口大小：占16位。&lt;/li&gt;
&lt;li&gt;校验和：占16位。&lt;/li&gt;
&lt;li&gt;紧急指针：占16位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四次挥手后的确认报文要等待2msl的时间释放tcp连接&#34;&gt;四次挥手后的确认报文要等待2MSL的时间释放TCP连接&lt;/h3&gt;
&lt;p&gt;如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL。&lt;/p&gt;
&lt;h3 id=&#34;http协议&#34;&gt;HTTP协议&lt;/h3&gt;
&lt;p&gt;HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是get、post、put、delete。这四种方法相当于对服务器资源进行查、改、增和删。
GET：从服务器上获取数据，相当于查，仅仅是获取服务器资源，不进行修改。
POST：向服务器提交数据，相当于改，涉及到了数据的更新，更改服务器的数据。
PUT：向服务器增加数据，相当于增。
DELETE：删除服务器数据，相当于删。&lt;/p&gt;
&lt;h3 id=&#34;get-和-post&#34;&gt;get 和 post&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;get是不安全的。在传输过程中，数据被放在请求的URL中；post的所有操作对于用户来说都是不可见的。也可以在get请求上加上request body，给post请求带上url参数。&lt;/li&gt;
&lt;li&gt;get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器给服务器加的。http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常进行，防止有人恶意发送请求。post请求没有大小限制。&lt;/li&gt;
&lt;li&gt;get限制form表单的数据集的值必须是ASCLL字符；而post支持整个ISO10646字符集。&lt;/li&gt;
&lt;li&gt;get执行效率比post方法好。get是form提交的默认方法。&lt;/li&gt;
&lt;li&gt;get产生一个TCP数据包；post产生两个TCP数据包。
&lt;ul&gt;
&lt;li&gt;get方式的请求，浏览器合集把http header和data一并发送出去，服务器响应200（返回数据）；&lt;/li&gt;
&lt;li&gt;post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-和-htpps&#34;&gt;HTTP 和 HTPPS&lt;/h3&gt;
&lt;h5 id=&#34;http的特点&#34;&gt;HTTP的特点：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;无状态。协议对客户端没有状态存储，对事物处理没有“记忆”能力。例，访问一个网站需要反复进行登录操作。&lt;/li&gt;
&lt;li&gt;无连接：由于无状态的特点，每次请求需要TCP三次握手四次挥手，和服务器重新建立连接。若某个客户端在短时间内多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，耗费不必要的时间和流量。&lt;/li&gt;
&lt;li&gt;基于请求和响应：由客户端发起请求，服务端响应&lt;/li&gt;
&lt;li&gt;简单快速、灵活&lt;/li&gt;
&lt;li&gt;通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性。
针对HTTP的无状态的解决策略：&lt;/li&gt;
&lt;li&gt;通过Cookie/Session技术&lt;/li&gt;
&lt;li&gt;持久连接，只要一方没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection:keep-alive即表明使用了持久连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;https的特点&#34;&gt;HTTPS的特点：&lt;/h5&gt;
&lt;p&gt;基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容加密：采用混合加密技术，中间者无法直接查看明文内容。&lt;/li&gt;
&lt;li&gt;验证身份：通过证书认证客户端访问的是自己的服务器。&lt;/li&gt;
&lt;li&gt;保护数据完整性：防止传输的内容被中间人冒充或者篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;区别&#34;&gt;区别&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;区别&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HTTP&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HTTPS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;协议&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;运行在TCP之上，明文传输，客户端与服务端都无法验证对方的身份&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;身披SSL外壳的HTTP，运行在SSL之上，SSL运行在TCP之上，是添加了加密和认证机制的HTTP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;端口&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;443&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;资源消耗&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较少&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;由于加密解密，会消耗更多的CPU和内存资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;开销&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无需证书&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要证书，而证书一般需要向认证机构购买&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;加密机制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;共享密钥加密和公开密钥加密兵俑的混合加密机制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;安全性&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;弱&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;由于加密机制，安全性强&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;常用http状态码&#34;&gt;常用HTTP状态码&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;类别&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;informational(信息性状态码)接受的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;success(成功状态码)请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redirection(重定向状态码)需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;client error(客户端错误状态码)服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;server error(服务器错误状态码)服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;sessioncookie和token&#34;&gt;Session、Cookie和Token&lt;/h3&gt;
&lt;h4 id=&#34;cookie&#34;&gt;cookie&lt;/h4&gt;
&lt;p&gt;cookie是由web服务器保存在用户浏览器上的小文件(key-value格式)，包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网站连同该cookie一同提交给服务器。服务器检查该cookie，以此来辨认用户身份。&lt;/p&gt;
&lt;h4 id=&#34;session&#34;&gt;session&lt;/h4&gt;
&lt;p&gt;session是依赖cookie实现的。session是服务端对象。
session是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置sessionID，浏览器在向服务器请求过程中传输cookie包含sessionID，服务器根据sessionID获取会话中存储的信息，然后确定会话的身份信息。&lt;/p&gt;
&lt;h4 id=&#34;cookie与session区别&#34;&gt;cookie与session区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;存储位置与安全性：cookie数据存放在客户端上，安全性较差。session数据存放在服务器上，安全性相对较高。&lt;/li&gt;
&lt;li&gt;存储空间：单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie，session无限制。&lt;/li&gt;
&lt;li&gt;占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cookie和session，一般认为是两个独立的东西，session采用的是在服务器端保持状态的方案，而cookie采用的是客户端保持状态的方案。
由于session是用Session ID来确定当前对话所对应的服务器session，而Session ID是通过cookie来传递的，禁用cookie相当于失去了session id，得不到session。
关闭cookie的情况下使用session，途径有：
1、手动通过URL传值、隐藏表单传递session id。
2、用文件、数据库等形式保存session id，在跨页过程中手动调用。&lt;/p&gt;
&lt;h4 id=&#34;token&#34;&gt;token&lt;/h4&gt;
&lt;h5 id=&#34;token的背景&#34;&gt;token的背景&lt;/h5&gt;
&lt;p&gt;客户端频繁向服务器请求数据，服务端频繁的去数据库查询用户名和密码并与之进行对比，判断用户名和密码是否正确&lt;/p&gt;
&lt;h5 id=&#34;token的定义&#34;&gt;token的定义&lt;/h5&gt;
&lt;p&gt;token是服务端生成的一串字符串，以作为客户端进行请求的一个令牌，当第一次登陆后，服务器生成一个token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。&lt;/p&gt;
&lt;h5 id=&#34;token的目的&#34;&gt;token的目的&lt;/h5&gt;
&lt;p&gt;为了减轻服务器的压力，减少频繁的查询数据库。
token是服务端产生的。如果前端使用用户名、密码向服务器请求认证，服务器认证成功，那么在服务器会返回token给前端。前端可以再每次请求的时候带上token证明自己的合法地位。&lt;/p&gt;
&lt;h4 id=&#34;session与token区别&#34;&gt;session与token区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；&lt;/li&gt;
&lt;li&gt;session存储在服务器端，token存储在客户端&lt;/li&gt;
&lt;li&gt;token提供认证和授权功能，作为身份认证，token安全性比session好&lt;/li&gt;
&lt;li&gt;session这种会话存储方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;servlet&#34;&gt;Servlet&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;ddddddddd&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>拷贝控制</title>
      <link>https://wangwei9160.github.io/post/copycontrol/</link>
      <pubDate>Fri, 19 Mar 2021 15:48:48 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/copycontrol/</guid>
      
        <description>&lt;h1 id=&#34;拷贝控制&#34;&gt;拷贝控制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;当定义一个类时，总显式或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。&lt;/li&gt;
&lt;li&gt;一个类通过定义五种特殊的成员函数来控制这些操作，包括：&lt;strong&gt;拷贝构造函数&lt;/strong&gt;、&lt;strong&gt;移动构造函数&lt;/strong&gt;、&lt;strong&gt;拷贝赋值运算符&lt;/strong&gt;、&lt;strong&gt;移动赋值运算符&lt;/strong&gt;和&lt;strong&gt;析构函数&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拷贝和移动构造函数&lt;/strong&gt;定义了当用同类型的另一个对象初始化本对象时做什么。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拷贝和移动赋值运算符&lt;/strong&gt;定义了将一个对象赋予同类型的另一个对象时做什么。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构函数&lt;/strong&gt;定义了当此类型对象销毁时做什么。
这些统称为&lt;strong&gt;拷贝控制操作&lt;/strong&gt;。如果不显式的定义这些操作，编译器也会为我们定义，但编译器定义的版本的行为可能并非我们所想的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拷贝赋值销毁&#34;&gt;拷贝、赋值、销毁&lt;/h2&gt;
&lt;h4 id=&#34;拷贝构造函数&#34;&gt;拷贝构造函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果一个构造函数的第一个参数是&lt;strong&gt;自身类类型&lt;/strong&gt;的&lt;strong&gt;引用&lt;/strong&gt;，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;合成拷贝构造函数&#34;&gt;合成拷贝构造函数：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;如果没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。&lt;/li&gt;
&lt;li&gt;对某些类来说，合成拷贝构造函数用来阻止拷贝该类类型的对象。一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。
&lt;ul&gt;
&lt;li&gt;每个成员的类型决定了它如何拷贝：
&lt;ul&gt;
&lt;li&gt;类类型的成员，会使用其拷贝构造函数来拷贝。&lt;/li&gt;
&lt;li&gt;内置类型的成员，直接拷贝。&lt;/li&gt;
&lt;li&gt;数据类型，合成拷贝构造函数会逐元素拷贝数组类型的成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;拷贝初始化&#34;&gt;拷贝初始化&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;直接初始化：实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。&lt;/li&gt;
&lt;li&gt;拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，有时可能有进行类型转换。
&lt;ul&gt;
&lt;li&gt;拷贝初始化不仅在使用=定义变量时发生，在以下情况也会发生：
&lt;ul&gt;
&lt;li&gt;将一个对象作为实参传递给一个非引用类型的形参&lt;/li&gt;
&lt;li&gt;从一个返回类型为非引用类型的函数返回一个对象&lt;/li&gt;
&lt;li&gt;用花括号列表初始化一个数组中的元素或一个聚合类的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拷贝/移动构造函数必须是存在的且可以访问的（例，不能是private）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;拷贝赋值运算符&#34;&gt;拷贝赋值运算符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;类控制其对象如何赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;合成拷贝赋值运算符&#34;&gt;合成拷贝赋值运算符&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;析构函数&#34;&gt;析构函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;析构函数释放对象使用的资源，并销毁对象的非static数据成员。&lt;/li&gt;
&lt;li&gt;析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数。由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;析构函数的调用&#34;&gt;析构函数的调用&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;无论何时一个对象被销毁，就会自动调用其析构函数：
&lt;ul&gt;
&lt;li&gt;变量在离开其作用域时被销毁。&lt;/li&gt;
&lt;li&gt;当一个对象被销毁时，其成员被销毁。&lt;/li&gt;
&lt;li&gt;容器被销毁时，其元素被销毁。&lt;/li&gt;
&lt;li&gt;动态分配的独享，当对指向它的指针引用delete运算符时被销毁。&lt;/li&gt;
&lt;li&gt;对于临时对象，当创建它的完整表达式结束时被销毁。
析构函数自动运行，通常情况下无须担心何时释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;合成析构函数&#34;&gt;合成析构函数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。对于某些类，合成析构函数被用来组织该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构函数体自身并不直接销毁成员&lt;/strong&gt;。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三五法则&#34;&gt;三/五法则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;拷贝构造函数、拷贝赋值运算符和析构函数作为三个基本操作可以控制类的拷贝操作。在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。&lt;/li&gt;
&lt;li&gt;通常情况下，这些操作应该看作一个整体，只需要其中一个操作而不定义所有操作的情况是很少见的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;default&#34;&gt;=default&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。&lt;/li&gt;
&lt;li&gt;当在类内使用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。如果不希望合成的成员是内联函数，应该只对成员的类外定义使用=default。&lt;/li&gt;
&lt;li&gt;只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;阻止拷贝&#34;&gt;阻止拷贝&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对于某些类来说，拷贝构造函数和拷贝赋值运算符是没有合理的意义的。如果不定义拷贝控制成员，编译器会为它生成合成的版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;定义删除的函数&#34;&gt;定义删除的函数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;通过将拷贝构造函数和拷贝赋值运算符定义为&lt;strong&gt;删除的函数&lt;/strong&gt;来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面机上=delete来指出我们希望将它定义为删除的。
&lt;ul&gt;
&lt;li&gt;=delete通知编译器，我们不希望定义这些成员。&lt;/li&gt;
&lt;li&gt;=delete必须出现在函数&lt;strong&gt;第一次声明&lt;/strong&gt;的时候。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构函数不能是删除的成员&lt;/strong&gt;。不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;交换操作&#34;&gt;交换操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;除了定义拷贝控制成员，管理资源的类通常还定义了swap函数。&lt;/li&gt;
&lt;li&gt;如果一个类定义了自己的swap，算法将使用类自定义版本。否则，算法将使用标准定义的swap。理论上，为了交换两个对象我们需要进行一次拷贝和两次赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;编写swap函数&#34;&gt;编写swap函数&lt;/h4&gt;
&lt;p&gt;在类上定义一个自己版本的swap来重载swap的默认行为。
将swap定义为friend，以便能访问private中的数据成员。由于swap的存在就是为了优化代码，可将其声明为inline函数。对给定对象的每个数据成员调用swap。
swap中调用的swap不是std::swap。数据成员是内置类型的，而当内置类型没有特定版本的swap时，对swap的调用会调用标准库std::swap。但是如果一个类的成员有自己类型特定的swap函数，调用std::swap就是错误的。&lt;/p&gt;
&lt;h4 id=&#34;在赋值运算符中使用swap&#34;&gt;在赋值运算符中使用swap&lt;/h4&gt;
&lt;p&gt;定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HasPtr&amp;amp; HasPtr::operator=(HasPtr rhs)
{
  swap(*this , rhs);
  return *this;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在其中rhs是按置传递的，意味着HasPtr的拷贝构造函数，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr的操作会分配该对象的一个新副本、
调用swap交换rhs和*this 中的数据成员。这个调用将左侧运算对象中原来保存的指针存入rhs中，并将rhs中原来的指针存入 *this中。因此，在swap调用之后， *this 中的指针成员将指向新分配的右侧运算对象的一个副本 。
当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。delete rhs现在指向的内存，即释放掉左侧运算对象中原来的内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象移动&#34;&gt;对象移动&lt;/h3&gt;
&lt;h4 id=&#34;右值引用&#34;&gt;右值引用&lt;/h4&gt;
&lt;p&gt;右值引用就是必须绑定到右值的引用。通过&amp;rdquo; &amp;amp;&amp;amp; &amp;ldquo;而不是&amp;rdquo; &amp;amp; &amp;ldquo;来获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。可以自由地将一个右值引用的资源“移动”到另一个对象中。
返回左值引用的函数，连同算术、关系、位以及后置递增/递减运算符，都是返回左值的表达式的梨子。可以将一个左值引用绑定到这类表达式的结果上。
返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。不能讲一个左值引用绑定到这类表达式上，但可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。&lt;/p&gt;
&lt;h5 id=&#34;左值持久右值短暂&#34;&gt;左值持久；右值短暂&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;左值&lt;/strong&gt;有持久的状态;&lt;strong&gt;右值&lt;/strong&gt;要么是&lt;strong&gt;字面常量&lt;/strong&gt;，要么是&lt;strong&gt;在表达式求值过程中创建的临时对象&lt;/strong&gt;。
由于右值引用只能绑定到临时号对象，我们得知&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所引用的对象将要被销毁&lt;/li&gt;
&lt;li&gt;该对象没有其他用户
因此，使用右值引用的代码可以自由得接管所引用的对象的资源。
&lt;strong&gt;变量是左值&lt;/strong&gt;。变量是持久的，直到离开作用域才会被销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;标准库move函数&#34;&gt;标准库move函数&lt;/h5&gt;
&lt;p&gt;虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。通过调用标准库函数中的move函数来获得绑定到左值上的右值引用。
move调用告诉编译器：有一个左值，但希望像一个右值一样处理它。同时调用move就意味着承诺：除了对其赋值或销毁它之外，将不会再使用它。在调用move之后，不能对移后源对象的值做任何假设。&lt;/p&gt;
&lt;h4 id=&#34;移动构造函数和移动赋值运算符&#34;&gt;移动构造函数和移动赋值运算符&lt;/h4&gt;
&lt;p&gt;类似于拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。
除了完成资源移动，移动构造函数还必须确保移后源对象处于&lt;strong&gt;销毁它是无害的&lt;/strong&gt;的状态。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属于新创建的对象。&lt;/p&gt;
&lt;h5 id=&#34;移后源对象必须可析构&#34;&gt;移后源对象必须可析构&lt;/h5&gt;
&lt;p&gt;从一个对象移动数据并不会销毁对象，但有时在移动操作完成之后，源对象会被销毁。因此当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。&lt;/p&gt;
&lt;h5 id=&#34;合成的移动操作&#34;&gt;合成的移动操作&lt;/h5&gt;
&lt;p&gt;与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成的条件不大相同。
与拷贝操作不同，编译器不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。因此，某些类就没有移动构造函数或移动赋值运算符。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。
&lt;strong&gt;只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符，编译器可以移动内置类型的成员。&lt;/strong&gt;
移动操作永远不能隐式地定义为删除的函数。如果显式地要求编译器生成=default的移动操作，切编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Leetcode第230场周赛</title>
      <link>https://wangwei9160.github.io/post/leetcode230/</link>
      <pubDate>Thu, 18 Mar 2021 14:59:48 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/leetcode230/</guid>
      
        <description>&lt;h1 id=&#34;leetcode周赛230&#34;&gt;leetcode周赛230&lt;/h1&gt;
&lt;h3 id=&#34;a-id0目录a&#34;&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#a-id1%E7%BB%9F%E8%AE%A1%E5%8C%B9%E9%85%8D%E6%A3%80%E7%B4%A2%E8%A7%84%E5%88%99%E7%9A%84%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8Fa&#34;&gt;统计匹配检索规则的物品数量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id2-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%ACa&#34;&gt;最接近目标价格的甜点成本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id3-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89a&#34;&gt;通过最少操作次数使数组的和相等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id4%E8%BD%A6%E9%98%9FII-a&#34;&gt;车队II&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-id1统计匹配检索规则的物品数量a&#34;&gt;&lt;!-- raw HTML omitted --&gt;统计匹配检索规则的物品数量&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/count-items-matching-a-rule/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目&#34;&gt;题目：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。
另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。
如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：
    ruleKey == &amp;quot;type&amp;quot; 且 ruleValue == typei 。
    ruleKey == &amp;quot;color&amp;quot; 且 ruleValue == colori 。
    ruleKey == &amp;quot;name&amp;quot; 且 ruleValue == namei 。
统计并返回 匹配检索规则的物品数量 。
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;思路&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;找到对应的值匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;int countMatches(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;&amp;amp; items, string ruleKey, string ruleValue) {
    int j = 0;
    if(ruleKey == &amp;quot;color&amp;quot;) j = 1;
    else if(ruleKey == &amp;quot;name&amp;quot;) j = 2;
    int cnt = 0;
    for( auto x : items) if(ruleValue == x[j]) cnt++;
    return cnt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id2-最接近目标价格的甜点成本a&#34;&gt;&lt;!-- raw HTML omitted --&gt; 最接近目标价格的甜点成本&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/closest-dessert-cost/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目-1&#34;&gt;题目：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：

必须选择 一种 冰激凌基料。
可以添加 一种或多种 配料，也可以不添加任何配料。
每种类型的配料 最多两份 。
给你以下三个输入：

baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。
toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。
target ，一个整数，表示你制作甜点的目标价格。
你希望自己做的甜点总成本尽可能接近目标价格 target 。

返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;思路-1&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;数据小，搜索。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-1&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;int ans = -1 ;

void dfs(int cost , vector&amp;lt;int&amp;gt;&amp;amp; b , int pos , int target){
    if(pos == b.size()){
        if(ans == -1 || abs(cost-target) &amp;lt; abs(ans-target) || abs(cost-target) == abs(ans-target) &amp;amp;&amp;amp; cost &amp;lt; ans){
            ans = cost;
        }
        return ;
    }
    
    dfs(cost , b , pos+1 , target);
    dfs(cost + b[pos] , b , pos+1 , target);
    dfs(cost + b[pos]*2 , b , pos+1 , target);
}


int closestCost(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b, int target) {
    ans = -1;
    int n = a.size();
    int m = b.size();
    for(auto x : a){
        dfs(x , b , 0 , target);
    }
    return ans;

}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id3通过最少操作次数使数组的和相等a&#34;&gt;&lt;!-- raw HTML omitted --&gt;通过最少操作次数使数组的和相等&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目-2&#34;&gt;题目：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。

每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。

请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;思路-2&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;小的往大了变，大的往小的变。
小的优先把1变成6，大的优先把6变1，在某一次中使得差值小于0，则次数即是答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-2&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;int minOperations(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
    int cnt[2][7] = {0} , sum[2] = {0};
    int j = 0;
    for(auto x : nums1) {++cnt[j][x];sum[j]+=x;}
    for(auto x : nums2) {++cnt[j^1][x];sum[j^1]+=x;}
    if(sum[0] &amp;gt; sum[1]) 
        return minOperations(nums2,nums1);
    
    int need = 0;
    int diff = sum[1] - sum[0];
    
    for(int i = 1 ; i &amp;lt;= 5 ; ++i){
        if(cnt[j][i] != 0){
            for(int k=0;k&amp;lt;cnt[j][i];++k){
                ++need;
                diff-= 6 - i;
                if(diff &amp;lt;= 0) break;
            }
        }
        if(diff &amp;lt;= 0) break;
        if(cnt[j^1][7-i] != 0){
            for(int k=0;k&amp;lt;cnt[j^1][7-i];++k){
                ++need;
                diff-= 6 - i;
                if(diff &amp;lt;= 0) break;
            }
        }
        if(diff &amp;lt;= 0) break;
    }
    if(diff &amp;gt; 0 ) return -1;
    return need;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id4车队iia&#34;&gt;&lt;!-- raw HTML omitted --&gt;车队II&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/car-fleet-ii/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目-3&#34;&gt;题目：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;在一条单车道上有 n 辆车，它们朝着同样的方向行驶。给你一个长度为 n 的数组 cars ，其中 cars[i] = [positioni, speedi] ，它表示：

positioni 是第 i 辆车和道路起点之间的距离（单位：米）。题目保证 positioni &amp;lt; positioni+1 。
speedi 是第 i 辆车的初始速度（单位：米/秒）。
简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。

请你返回一个数组 answer ，其中 answer[i] 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 answer[i] 为 -1 。答案精度误差需在 10-5 以内。
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;思路-3&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;利用栈的思想，栈底是最慢的车，栈顶是最快的车。
如果ans[i]&amp;gt;0，则一定是cars[i]和某一个cars[j]相遇了且j&amp;gt;i &amp;amp;&amp;amp; speed[j]&amp;lt;speed[i]。反之ans[i]=-1，永远无法消失。
在碰撞的情况下，可以将cars[i]当做消失，cars[j]的状态依旧不变。左边的车对cars[i]是没有影响的。故仅考虑一辆车的右边即可。
如果栈顶元素比cars[i]快，则永远无法碰撞，出战。
反之，必定可以碰撞。由于是从右往左遍历ans[栈顶]可知，若ans[栈顶]=-1(不消失)，则一定在某一时刻碰撞计算即可。若ans[栈顶]&amp;gt;0(会消失)，需要计算是否在碰撞前相遇，如果能再碰撞前相遇则直接计算何时碰撞，若不能，则选择追逐栈顶的前一辆车。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-3&#34;&gt;代码:&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;double&amp;gt; getCollisionTimes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cars) {
    int n = cars.size();
    vector&amp;lt;double&amp;gt; ans(n , -1);
    stack&amp;lt;int&amp;gt; s;
    auto calc = [&amp;amp;](int i , int j){
        return 1.0*(cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);
    };
    s.push(n-1);
    for(int i = n - 2 ; ~i ; --i){
        while(s.size() ){
            if(cars[s.top()][1] &amp;gt;= cars[i][1]) s.pop();
            else {
                if(ans[s.top()] &amp;lt; 0) break;
                double d = ans[s.top()]*(cars[i][1] - cars[s.top()][1]);
                if(d &amp;gt; (cars[s.top()][0] - cars[i][0])) break;
                else s.pop();
            }
        }
        if(s.empty()) ans[i] = -1;
        else ans[i] = calc(i , s.top());
        s.push(i);
    }
    return ans;

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;#a-id0%E7%9B%AE%E5%BD%95a&#34;&gt;回到目录&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>动态内存</title>
      <link>https://wangwei9160.github.io/post/dynamicallyallocate/</link>
      <pubDate>Wed, 17 Mar 2021 14:36:36 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/dynamicallyallocate/</guid>
      
        <description>&lt;h2 id=&#34;动态内存&#34;&gt;动态内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局对象在程序启动时分配，在程序结束时销毁；局部自动对象，当进入其定义所在的程序块时被创建，在离开块时销毁；局部static对象在第一次使用前分配，在程序结束时销毁。&lt;/li&gt;
&lt;li&gt;动态分配的对象的生存期与他们在哪里创建是无关的，只有当显式地被释放时，这些对象才销毁。&lt;/li&gt;
&lt;li&gt;标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被销毁时，指向它的只能指针可以确保自动地释放它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智能指针&#34;&gt;智能指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态内存的管理是通过&lt;strong&gt;new&lt;/strong&gt;和&lt;strong&gt;delete&lt;/strong&gt;来完成的。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;new&lt;/strong&gt;：在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;delete&lt;/strong&gt;：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标准库提供了两种&lt;strong&gt;智能指针&lt;/strong&gt;类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;shared_ptr&lt;/strong&gt;：允许多个指针指向同一个对象。在最后一个shared_ptr析构的时候，内存才会释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;：&amp;lsquo;独占&#39;所指向的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weak_ptr&lt;/strong&gt;：弱引用，指向shared_ptr所管理的对象。
这三种类型都定义在memory头文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shared_ptr&#34;&gt;shared_ptr&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;shared_ptr和unique_ptr都支持的操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;shared_ptr&amp;lt; T&amp;gt; sp、unique_ptr&amp;lt; T&amp;gt; sp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空智能指针，可以指向类型为T的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;将p用作一个条件判断，若p指向一个对象，则为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;*p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解引用p，获得它指向的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p-&amp;gt;mem&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;等价于(*p).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p.get()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回p中保存的指针。若智能指针释放了其对象，返回的指针所指向的对象也就消失了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;swap(p,q)、p.swap(q)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;交换p和q中的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;shared_ptr独有的操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;make_shared&amp;lt; T&amp;gt;(args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;shared_ptr&amp;lt; T&amp;gt;p(q)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;p是shared_ptr类型q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p = q&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;p和q都是shared_ptr类型，保存的指针必须能相互转换。此操作会递减p的引用计数，递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p.unique()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;若p.use_count()为1，返回true；否则返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p.use_count()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回与p共享对象的智能指针数量；主要用于调试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最安全的分配和使用动态内存的方法是调用make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。通常用auto定义一个对象来保存make_shared_ptr的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个shared_ptr都有一个关联的计数器，&lt;strong&gt;引用计数&lt;/strong&gt;。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。&lt;/li&gt;
&lt;li&gt;shared_ptr类会自动销毁此独享。它是通过另一个特殊的成员函数——&lt;strong&gt;析构函数&lt;/strong&gt;完成销毁工作的。类似于构造函数，每个类都有一个析构函数。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。&lt;/li&gt;
&lt;li&gt;当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;使用动态生存期的资源的类&#34;&gt;使用动态生存期的资源的类&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;程序使用动态内存出于以下三种原因之一：
1、程序不知道自己需要使用多少对象
2、程序不知道所需对象的准确类型
3、程序需要在多个对象间共享数据
容器类是出于第一种原因而使用动态内存的典型例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直接管理内存&#34;&gt;直接管理内存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;new、delete&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;相比于智能指针，直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用new动态分配和初始化对象&#34;&gt;使用new动态分配和初始化对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针。&lt;/li&gt;
&lt;li&gt;默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。&lt;/li&gt;
&lt;li&gt;可以使用直接初始化方法来初始化一个动态分配的对象，也可以使用传统的构造方式（圆括号）。在新标准下，也可以使用列表初始化（花括号）。&lt;/li&gt;
&lt;li&gt;如果提供一个括号保卫的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。当括号中仅有一个单一初始化器时才可以使用auto。&lt;/li&gt;
&lt;li&gt;用new分配const对象是合法的。虽然const对象的值不能被改变，但它本身是可以被销毁的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存耗尽&#34;&gt;内存耗尽&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。
&lt;blockquote&gt;
&lt;p&gt;//如果分配失败，new返回一个空指针
int *p1 = new int;//如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int;//如果分配失败,new返回一个空指针
这种形式的new为&lt;strong&gt;定位new&lt;/strong&gt;(placement new)。定位new表达式允许我们向new传递额外的参数。如果nothrow传递给new，试图告诉它不能抛出异常。如果这种形式的new不能分配所需要的内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;释放动态内存&#34;&gt;释放动态内存&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为了防止内存耗尽，通过&lt;strong&gt;delete表达式&lt;/strong&gt;来将内存归还给系统。delete表达式接受一个指针，指向我们想要释放的对象。delete表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;动态内存的管理&#34;&gt;动态内存的管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用new和delete管理动态内存常见的三个问题：
1、忘记delete内存。
2、使用已经释放掉的对象。
3、同一块内存释放两次。
只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;空悬指针&#34;&gt;空悬指针&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在delete之后，指针就变成&lt;strong&gt;空悬指针&lt;/strong&gt;(dangling pointer)，指向一块曾经保存数据对象但现在已经无效的内存的指针。&lt;/li&gt;
&lt;li&gt;未初始化指针的所有缺点空悬指针也有。避免空悬指针的问题：在指针即将要离开其作用域之前释放掉它所关联的内存。这样，在指针关联的内存被释放掉之后，就没有机会继续使用指针了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;动态内存的问题&#34;&gt;动态内存的问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重置指针的方法只对这个指针有效，对其他任何仍指向（已释放）内存的指针是没有作用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;unique_ptr操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;unique_ptr&amp;lt; T&amp;gt; u1 、 unique_ptr&amp;lt; T , D&amp;gt; u2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用类型为D的可调用对象来释放它的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;unique_ptr&amp;lt; T, D&amp;gt; u(d)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;u = nullptr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;释放u指向的对象，将u置为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;u.release()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;u放弃对指针的控制权，返回指针，并将u置为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;u.reset()、u.reset(q)、u.reset(nullptr)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;释放u指向的对象。如果提供了内置指针q，令u指向这个对象；否则将u置为空&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;虽然不能拷贝unique_ptr，但是可以通过拷贝或赋值一个将要被销毁的unique_ptr。最常见的就是从函数返回一个unique_ptr。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;weak_ptr&#34;&gt;weak_ptr&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。即使有weak_ptr指向最后一个指对象的shared_ptr被销毁，对象还是会被释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;weak_ptr&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;weak_ptr&amp;lt; T&amp;gt; w&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空weak_ptr可以指向类型为T的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;weak_ptr&amp;lt; T&amp;gt; w(sp)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;与shared_ptr sp 指向相同对象的weak_ptr。T必须能转换为sp指向的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;w = p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;p可以是一个shared_ptr或weak_ptr。赋值后w与p共享对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;w.reset()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;将w置为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;w.use_count()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;与w共享对象的shared_ptr的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;w.expired()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;若w.use_count()为0，返回true，否贼返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;w.lock()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;如果expired为true，返回一个空的shared_ptr；否贼返回一个指向w的对象的shared_ptr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;动态数组&#34;&gt;动态数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;new和delete运算符一次分配/释放一个对象，但是某些应用需要一次为很多对象分配内存的功能。为了支持这种需求，提供了两种一次分配一个对象数组的方法。
&lt;ul&gt;
&lt;li&gt;c++语言定义了另一种new表达式，可以分配一个对象数组。&lt;/li&gt;
&lt;li&gt;标准库的allocator类，允许将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Git</title>
      <link>https://wangwei9160.github.io/post/git/</link>
      <pubDate>Sat, 13 Mar 2021 13:27:30 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/git/</guid>
      
        <description>&lt;h1 id=&#34;github-repository&#34;&gt;github repository&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用github创建仓库时的步骤，windows&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建仓库&#34;&gt;创建仓库&lt;/h2&gt;
&lt;h3 id=&#34;1-new-repository&#34;&gt;1、 new repository&lt;/h3&gt;
&lt;p&gt;在github界面选择new一个repository&lt;/p&gt;
&lt;h3 id=&#34;2设置repository信息&#34;&gt;2、设置Repository信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设置Repository name、Description（可不填）&lt;/li&gt;
&lt;li&gt;为初始化仓库的信息文件。（可不添加）&lt;/li&gt;
&lt;li&gt;Add a README file ： 添加说明文件MEADME.md。直接使用Description中的内容作为文件的内容，也可以在创建仓库后仓库主界面选择Add file，Create new file中添加MEADME.md&lt;/li&gt;
&lt;li&gt;Add .gitignore ： 在使用git的过程中有些日志文件、临时文件、编译产生的中间文件不需要纳入git的管理，可以再gitignore中列出要忽略的文件模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3create-repository&#34;&gt;3、Create repository&lt;/h3&gt;
&lt;p&gt;点击Create repository&lt;/p&gt;
&lt;h2 id=&#34;4进到repository主界面&#34;&gt;4、进到repository主界面&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建结束自动跳转(大概会github不崩的话)&lt;/li&gt;
&lt;li&gt;可以通过访问 github.com/xxxx/name
xxxx 是自己的github用户名，name是repository的name&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5点击code-查看信息&#34;&gt;5、点击code 查看信息&lt;/h3&gt;
&lt;p&gt;点击code 可以查看到https、ssh、github CLI&lt;/p&gt;
&lt;h3 id=&#34;6在本地创建一个目录&#34;&gt;6、在本地创建一个目录&lt;/h3&gt;
&lt;p&gt;提前部署好git&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自己的主机上想要的位置存放这个仓库的更新内容以及推送更新，在响应的位置上右键选择Git Bash Here.&lt;/li&gt;
&lt;li&gt;git clone &lt;a href=&#34;https://github.com/xxxx/name.git&#34;&gt;https://github.com/xxxx/name.git&lt;/a&gt;
xxxx 是github用户名，name是repository的name&lt;/li&gt;
&lt;li&gt;cd name
通过cd 进入到本地的仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-添加想添加的文件&#34;&gt;7、 添加想添加的文件&lt;/h3&gt;
&lt;h3 id=&#34;8-使用git&#34;&gt;8、 使用git&lt;/h3&gt;
&lt;p&gt;通过cd进入到name目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cd xx/xx/name&lt;/li&gt;
&lt;li&gt;git add .&lt;/li&gt;
&lt;li&gt;git commit -m &amp;ldquo;new&amp;rdquo;&lt;/li&gt;
&lt;li&gt;git push -u origin main
在新建仓库分支是main。可以在git中查看对应的分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;维护repository&#34;&gt;维护repository&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;git add .&lt;/li&gt;
&lt;li&gt;git commit -m &amp;ldquo;new&amp;rdquo;&lt;/li&gt;
&lt;li&gt;git push -u origin main
在新建仓库分支是main。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Allocator</title>
      <link>https://wangwei9160.github.io/post/allocator/</link>
      <pubDate>Fri, 12 Mar 2021 11:34:39 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/allocator/</guid>
      
        <description>&lt;h2 id=&#34;allocator&#34;&gt;allocator&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;标准库allocator类定义在头文件memory中，它帮助我们将内存分配和独享构造分离开来。提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。&lt;/li&gt;
&lt;li&gt;当一个allocator对象分配内存时，allocator会根据给定的对象类型来确定恰当的内存大小和对齐位置：
&lt;blockquote&gt;
&lt;p&gt;allocator&lt;!-- raw HTML omitted --&gt; alloc;            //可以分配string的allocator对象
auto const p = alloc.allocate(n);   //分配n个未初始化的string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;写法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;allocator &amp;lt; T &amp;gt; a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;定义了一个名为a的allocator对象，为类型T的对象分配内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.allocate(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;分配一段原始的、未构造的内存，保存n个类型为T的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.deallocate(p,n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;释放从T*指针p中地址开始的内存，这块内存保存了n个类为T的对象；T必须是一个先前由allocate返回的指针，n必须是p创建时所要求的大小。在调用之前必须对每个这块内存中创建的对象调用destory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.construct(p,args)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;T*类型指针p，指向原始内存，arg被传递给类型为T的构造函数，用来构造一个对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.destroy(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;T*类型指针p，对p指向的对象进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;allocator&lt;!-- raw HTML omitted --&gt; alloc;         &lt;br&gt;
auto const p = alloc.allocate(n);&lt;br&gt;
auto q = p ;                      // q指向最后构造的元素之后的位置&lt;br&gt;
alloc.construct(q++);             // *q为空字符串  &lt;br&gt;
alloc.construct(q++, 10 , &amp;lsquo;c&amp;rsquo;);   //*q为cccccccccc&lt;br&gt;
alloc.construct(q++ , &amp;ldquo;hi&amp;rdquo; ) ;    //*q为hi!&lt;br&gt;
while (q != p)  alloc.destory(&amp;ndash;q); // 释放真正构造的string
alloc.deallocator(p,n);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;拷贝和填充未初始化内存的算法&#34;&gt;拷贝和填充未初始化内存的算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;allocator算法&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;uninitialized_copy( b , e , b2 )&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能容纳输入序列中元素的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;uninitialized_copy_n( b , n , b2 )&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;uninitialized_fill( b , e , t )&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;uninitialized_fill_n( b , n , t )&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;预计自己写的allocator类&#34;&gt;预计自己写的allocator类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;大体思路&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;allocate&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;默认生成一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;allocate(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;生成多个,n&amp;gt;=0,特判0的情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dellocate(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;默认释放一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dellocate(p,n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;释放多个,n&amp;gt;=0,特判0的情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;构造一个默认为空的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p,T&amp;amp;)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;创建一个对象，方式是调用T的有参构造函数，参数为传过来的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p,T)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;创建一个对象，方式是调用T的有参构造函数，参数为传过来的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p,Args)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;带参数列表的构造&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对p所指的对象进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy(p,n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对p所指的对象进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy(p1,p2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对p1到p2的空间进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>Word</title>
      <link>https://wangwei9160.github.io/post/word/</link>
      <pubDate>Mon, 01 Mar 2021 11:53:30 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/word/</guid>
      
        <description>&lt;h1 id=&#34;英语单词-or-小短文&#34;&gt;英语单词 or 小短文&lt;/h1&gt;
&lt;h3 id=&#34;210301&#34;&gt;21.03.01&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>C&#43;&#43;</title>
      <link>https://wangwei9160.github.io/post/cplusplus/</link>
      <pubDate>Sun, 28 Feb 2021 17:47:04 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/cplusplus/</guid>
      
        <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;内容参考自c++ primer 第五版和网上的一些资料。仅供自己学习参考使用。&lt;/li&gt;
&lt;li&gt;主要形式是通过实现部分STL库文件，增加对STL库的理解。会逐步进行完善。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;c&#34;&gt;c++&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，查找int类型的vector中是否包含一个特定值，可以使用find函数。
&lt;blockquote&gt;
&lt;p&gt;int val = 1;
auto result = find( vec.cbegin() , vec.cend () , val );&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数调用的解析过程&lt;/strong&gt;
假定调用obj.mem()，则依次执行以下4个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先确定obj的静态类型。调用的是一个成员，所以该类型必须是类类型。&lt;/li&gt;
&lt;li&gt;在obj的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直到继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。&lt;/li&gt;
&lt;li&gt;一旦找到了mem，就进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法。&lt;/li&gt;
&lt;li&gt;假设调用合法，则编译器将根据是否是虚函数而产生不同的代码：
&lt;ul&gt;
&lt;li&gt;如果mem是虚函数且我们是通过引用或指针进行的拷贝，则编译器产生的代码将在运行时确定到底运行的是哪个版本，依据是对象的动态类型。&lt;/li&gt;
&lt;li&gt;反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用，则编译器将产生一个常规函数调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;size_t&lt;/strong&gt; ： 定义在cstdef头文件中，是一个与机器相关的unsigned类型，其大小足以存储内存中对象的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;decltype&lt;/strong&gt;：如果明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，假设两个函数返回类型都是string::size_type，并且各有两个const string&amp;amp;类型的形参，此时我们可以便携第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;string::size_type sumLength(const string&amp;amp; , const string&amp;amp;);
string::size_type largerLength(const string&amp;amp; , const string&amp;amp;);
decltype(sumLength) *getFcn(const string&amp;amp;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将decltype作用于某个函数时，它返回函数类型而不是指针类型。因此，我们显示地加上*以表示我们需要返回指针，而不是函数本身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;at成员函数&lt;/strong&gt; ： at成员函数类似于下标运算符，但如果下标越界，at会抛出一个out_of_range异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;explicit&lt;/strong&gt;：在要求隐式转换的程序上下文中，通过将构造函数声明为explicit加以阻止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。&lt;/li&gt;
&lt;li&gt;发生隐式转换的一种情况是执行拷贝形式的初始化，此时我们只能&lt;strong&gt;直接初始化&lt;/strong&gt;而不能使用explicit构造函数。&lt;/li&gt;
&lt;li&gt;可以使用static_cast执行了显示的非隐式的转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类通过一个或几个特殊的成员函数来控制其对象的初始化过程。&lt;/li&gt;
&lt;li&gt;默认构造函数：类通过一个特殊的构造函数来控制默认初始化过程。默认构造函数无须任何实参。&lt;/li&gt;
&lt;li&gt;合成的默认构造函数：由编译器创建的构造函数。一般合成的默认构造函数将按照如下规则初始化类的数据成员：
&lt;ul&gt;
&lt;li&gt;如果存在类内的初始化，用它来初始化成员。&lt;/li&gt;
&lt;li&gt;否则，默认初始化该成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;move&lt;/strong&gt;：定义在utility头文件中。move有两个关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当reallocate在新内存中构造时，塔必须调用move来表示希望使用移动构造函数。如果漏掉了move调用，会使用拷贝构造函数。&lt;/li&gt;
&lt;li&gt;通常不为move提供一个using生命。直接调用std::move而不是move。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;noexcept&lt;/strong&gt;：承诺一个函数不跑出异常的一种方法。在构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于用户和编译器来说，预先知道某个函数不会跑出异常显然大有裨益。
&lt;ul&gt;
&lt;li&gt;知道函数不会跑出异常有助于简化调用该函数的代码&lt;/li&gt;
&lt;li&gt;如果编译器确认函数不会跑出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编译器并不会在编译时检查noexcept说明。尽管函数声明了它不会跑出异常，但实际上还是跑出了。一旦一个noexcept函数跑出了异常，程序就会调用terminate以确保遵守不在运行时跑出异常的承诺。因此noexcept一般在两种情况下使用：
&lt;ul&gt;
&lt;li&gt;确认函数不会排除异常。&lt;/li&gt;
&lt;li&gt;根本不知道该如何处理异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果是true，函数不会抛出异常；如果是false，则函数可能跑出异常。例：noexcept(true)。&lt;/li&gt;
&lt;li&gt;noexcept运算符：一元运算符，返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会跑出异常，并不会求表达式的值。&lt;/li&gt;
&lt;li&gt;如果一个虚函数承诺了它不会跑出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许跑出异常，则派生类的对应函数既可以允许跑出异常，也可以不允许跑出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;volatile&lt;/strong&gt;：volatile提醒编译器它后面所定义的变量随时可能改变，因此编译后的程序每次都需要存储或读取这个变量时，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，使用暂存在寄存器中的值。volatile修饰变量的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备的硬件寄存器（如：状态寄存器）&lt;/li&gt;
&lt;li&gt;一个中断服务子程序会访问到的非自动变量（Non-automatic variables）&lt;/li&gt;
&lt;li&gt;多线程应用中被几个任务共享的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**extern ”C” **：c语言不允许存在同名对象，比如在一个编译单元内部，不存在同名的函数。而c++允许对一个名字基于不同的定义，只要在语义上没有二义性。如果整个工程中由多个源文件组成，在一个源文件中想引用另外一个源文件中已经定义的全局变量，只需要在引用变量的文件中用extern关键字声明。如果不在文件的开头定义，则有效的作用范围也仅限于起定义处到文件结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顺序容器包括：&lt;strong&gt;vector,deque,list,forward_list,array,string&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;string&lt;/strong&gt;和&lt;strong&gt;vector&lt;/strong&gt;。由于元素是连续存储的，由元素的下标来计算其地址是非常快的。为保持连续存储，添加一个元素可能要分配额外的存储空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;list&lt;/strong&gt;和&lt;strong&gt;forward_list&lt;/strong&gt;。是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为访问一个元素，只能遍历整个容器。与vector,deque,array相比，这两个容器的额外内存开销也很大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deque&lt;/strong&gt;。与vector和string类似，deque支持快速的随机访问，中间位置添加或删除元素的代价很大。但是，两端添加或删除元素很快，与list和forward_list的速度相当。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assign&lt;/strong&gt;操作 （仅顺序容器）。允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。
&lt;blockquote&gt;
&lt;p&gt;list&lt;!-- raw HTML omitted --&gt; names;
vector&amp;lt;const char*&amp;gt; oldstyle;
names.assign(oldstyle.cbegin(),oldstyle.cend ());
list&lt;!-- raw HTML omitted --&gt; slist1(1);//1个元素，为空string。
slist1.assign(10,&amp;ldquo;Hiya!&amp;quot;);//10个元素，每个都是&amp;quot;Hiya!&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;顺序容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;vector&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;deque&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双端队列。支持快速随机访问。在头尾位置插入/伤处速度很快。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;forward_list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;单向链表。只支持单向顺序访问。在链表中任何位置进行插入/删除操作速度都很快。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;array&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;固定大小数组。支持快速随机访问。不能添加或删除元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;容器操作&#34;&gt;容器操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型别名&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;此容器类型的迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_iterator&lt;/td&gt;
&lt;td&gt;可以读取元素，但不能修改元素的迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;size_type&lt;/td&gt;
&lt;td&gt;无符号整数类型，足够保存此种容器类型最大可能容器的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;difference_type&lt;/td&gt;
&lt;td&gt;带符号类型，足够保存两个迭代器之间的距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;value_type&lt;/td&gt;
&lt;td&gt;元素类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reference&lt;/td&gt;
&lt;td&gt;元素的左值类型；与value_type&amp;amp;含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_reference&lt;/td&gt;
&lt;td&gt;元素的const左值类型（即，const value_type&amp;amp;）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;构造函数&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C c&lt;/td&gt;
&lt;td&gt;默认构造函数，构造空容器(array有单独的构造函数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c1(c2)&lt;/td&gt;
&lt;td&gt;构造c2的拷贝c1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c(b,e)&lt;/td&gt;
&lt;td&gt;构造c，将迭代器 b 和 e 指定的范围内的元素拷贝到t(array不支持)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c(a,b,c,d&amp;hellip;)&lt;/td&gt;
&lt;td&gt;列表初始化t&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;赋值与swap&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c1 = c2&lt;/td&gt;
&lt;td&gt;将c1中的元素替换为c2中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c1 = {a,b,c&amp;hellip;}&lt;/td&gt;
&lt;td&gt;将c1中的元素替换为列表中元素(不适用于array)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a.swap(b)&lt;/td&gt;
&lt;td&gt;交换a和b的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;swap(a,b)&lt;/td&gt;
&lt;td&gt;a.swap(b)等价&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.size()&lt;/td&gt;
&lt;td&gt;c中元素的数目(不支持forward_list)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.max_size()&lt;/td&gt;
&lt;td&gt;c可保存的最大元素数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.empty()&lt;/td&gt;
&lt;td&gt;若c中存储了元素，返回false，否则返回true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;添加/删除元素(不适用于array)&lt;/th&gt;
&lt;th&gt;不同容器中，操作的接口不同&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.insert(args)&lt;/td&gt;
&lt;td&gt;将args中的元素进行拷贝进c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.emplace(inits)&lt;/td&gt;
&lt;td&gt;使用inits构造c中的一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.erase(args)&lt;/td&gt;
&lt;td&gt;除args指定的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.clear()&lt;/td&gt;
&lt;td&gt;删除c中的所有元素，返回void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关系运算符&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;==,!=&lt;/td&gt;
&lt;td&gt;所有容器都支持相等(不等)运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;关系运算符(无序关联容器不支持)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;获取迭代器&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.begin(),c.end ()&lt;/td&gt;
&lt;td&gt;返回指向c的首元素和尾元素之后位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.cbegin(),c.cend ()&lt;/td&gt;
&lt;td&gt;返回const_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;反向容器的额外成员&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;reverse_iterator&lt;/td&gt;
&lt;td&gt;按逆序寻址元素的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_reverse_iterator&lt;/td&gt;
&lt;td&gt;不能修改元素的逆序迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.rbegin(),c.rend ()&lt;/td&gt;
&lt;td&gt;返回指向c的尾元素和首元素之前位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.crbegin(),c.crend ()&lt;/td&gt;
&lt;td&gt;返回const_reverse_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;vector对象是如何增长的&#34;&gt;vector对象是如何增长的:&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器大小管理操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;shrink_to_fit只适用于vector、string和deque&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;capacity和reserve只适用于vector和string&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.shrink_to_fit&lt;/td&gt;
&lt;td&gt;将capacity()减少为与size()相同大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.capacity()&lt;/td&gt;
&lt;td&gt;不重新分配内存空间的话，c可以保存多少元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.reserve(n)&lt;/td&gt;
&lt;td&gt;分配至少能容纳n个元素的内存空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;capacity和size。容器的size是指已经保存的元素的数目；而capacity则是不分配新的内存空间的前提下它最多可以保存多少元素。在标准库的实现中，每次添加1个元素，共添加24个元素，会使capacity变为32.&lt;/li&gt;
&lt;li&gt;调用shrink_to_fit只是一个请求，标准库并不保证退还内存。&lt;/li&gt;
&lt;li&gt;每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当&lt;strong&gt;迫不得已&lt;/strong&gt;时才可以分配新的内存空间。所有实现都应遵循一个原则：确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector，所花费的时间不能超过n的常数倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。&lt;strong&gt;适配器&lt;/strong&gt;是标准库中的一个通用概念。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。&lt;/li&gt;
&lt;li&gt;默认情况下，stack和queue是基于&lt;strong&gt;deque&lt;/strong&gt;实现的，priority_queue是在&lt;strong&gt;vector&lt;/strong&gt;基础上实现的。&lt;/li&gt;
&lt;li&gt;对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array直伤。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;泛型算法&#34;&gt;泛型算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为弄清算法如何用于不同类型的容器，分析find是如何在未排序的元素序列中查找一个指定元素。
&lt;ol&gt;
&lt;li&gt;访问序列中的首元素。&lt;/li&gt;
&lt;li&gt;比较此元素与我们要查找的值。&lt;/li&gt;
&lt;li&gt;如果此元素与我们要查找的值匹配，find返回标识此元素的值。&lt;/li&gt;
&lt;li&gt;否则，find前进到下一个元素，重复执行步骤2和3.&lt;/li&gt;
&lt;li&gt;如果到达序列尾部，find应停止。&lt;/li&gt;
&lt;li&gt;如果find到达序列尾部，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这些步骤都不需要依赖于容器所保存的元素类型。因此，只要有一个迭代器就可以用来访问元素，find就完全不依赖于容器的类型。&lt;/li&gt;
&lt;li&gt;迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。只需要迭代器就可以进行除了上述第二步之外的所有操作。但第二步中我们需要使用元素类型上的操作，find需要用到元素类型的==运算符完成每个元素与给定值的比较。在大多数的算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;谓词&#34;&gt;谓词&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的的谓词分为两类：&lt;strong&gt;一元谓词&lt;/strong&gt;(unary predicate，意味着他们只接受单一参数)和&lt;strong&gt;二元谓词&lt;/strong&gt;(binary prediacate,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。
&lt;ul&gt;
&lt;li&gt;接受一个二元谓词参数的sort版本用这个谓词代替&amp;lt;来比较元素。我们提供给sort的谓词必须满足在关键字类型上定义一个&lt;strong&gt;严格弱序&lt;/strong&gt;(strict weak ordering)。可以讲严格弱序看做&#39;&amp;lsquo;小于等于&amp;rsquo;&#39;,虽然实际上定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：
&lt;ul&gt;
&lt;li&gt;两个关键字不能同时“小于等于”对方.&lt;/li&gt;
&lt;li&gt;如果k1&amp;quot;小于等于&amp;quot;k2,且k2&amp;quot;小于等于&amp;quot;k3,那么k1必须&amp;quot;小于等于&amp;quot;k3.&lt;/li&gt;
&lt;li&gt;如果存在两个关键字，任何一个都不&amp;quot;小于等于&amp;quot;另一个,那么我们称这两个关键字是&amp;quot;等价&amp;quot;的.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;我们可以向一个算法传递任何类型的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以便携代码e(args)，其中args是一个逗号分隔的一个或多个参数的列表。&lt;/li&gt;
&lt;li&gt;一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：
&lt;blockquote&gt;
&lt;p&gt;[ capture list ] ( parameter list ) -&amp;gt; return type { function body }
auto f = [] {return 42;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;参数绑定&#34;&gt;参数绑定&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。&lt;/li&gt;
&lt;li&gt;如果lambda的捕获列表为空，通常可以用函数来代替它。但是对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。例如，我们用在find_if调用中的lambda比较一个string和一个给定大小可以使用
&lt;blockquote&gt;
&lt;p&gt;bool check_size(const string &amp;amp;s,string::size_type sz){
return s.size() &amp;gt;= sz;
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;但是，我们不用能这个函数作为find_if的一个参数。find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;标准库bind函数&#34;&gt;标准库bind函数&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;我们可以使用bind函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来&amp;quot;适应&amp;quot;原对象的参数列表。调用bind的一般形式为
&lt;ul&gt;
&lt;li&gt;auto newCallable = bind(callable , arg_list)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是&amp;quot;占位符&amp;rdquo;，表示newCallable的参数，它们占据了传递给newCallable的参数的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;bind的参数&#34;&gt;bind的参数：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;auto g = bind(f , a , b , _2 , c , _1);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个分别被绑定在给定值a、b和c上。&lt;/li&gt;
&lt;li&gt;传递给g的参数按位置绑定到占位符。第一个参数绑定到_1，第二个参数绑定到_2.因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个 参数将被传递给f作为第三个参数。这个bind调用会将
&lt;ul&gt;
&lt;li&gt;g(_1 , _2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;映射为
&lt;ul&gt;
&lt;li&gt;f(a , b, _2 , c, _1);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用g(X , Y ) 会调用 f(a, b, X, c, Y)&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;例如用bind重排参数顺序&#34;&gt;例如用bind重排参数顺序：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;按单词长度由短到长排序
sort(words.begin(),words.end (), isShorter);
按单词长度由长到短排序
sort(words.begin(),words.end (), bind(isShorter, _2, _1));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;标准库在iterator中定义了额外几种迭代器。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入迭代器（insert iterator）&lt;/strong&gt;：这些迭代器被绑定在一个容器上，可用来向容器插入元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流迭代器（stream iterator）&lt;/strong&gt;：这些迭代器被绑定到输入或输出流上，可用来遍历所相关联的io流。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向迭代器（reverse iterator）&lt;/strong&gt;：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动迭代器（move iterator）&lt;/strong&gt;：这些专用的迭代器不是拷贝其中的元素，而是移动它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;插入迭代器&#34;&gt;插入迭代器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入器是一种迭代器适配器。它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入器有三种类型，差异在于元素插入的位置：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;back_inserter&lt;/strong&gt;创建一个使用push_back的迭代器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;front_inserter&lt;/strong&gt;创建一个使用push_front的迭代器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inserter&lt;/strong&gt;创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
当调用inserter(c , iter)时，我们得到一个迭代器，接下来使用它时，会讲元素插入到iter原来指向的元素之前的位置。即，如果it是由inserter生成的迭代器，则赋值语句：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;*it = val;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与下面的语句效果一样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;it = c.insert(it, val);
++it;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;iostream迭代器&#34;&gt;iostream迭代器&lt;/h5&gt;
&lt;p&gt;虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器，istream_iterator读取输入流，ostream_iterator向一个输出流写数据。&lt;/p&gt;
&lt;h6 id=&#34;istream_iterator&#34;&gt;istream_iterator&lt;/h6&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;istream_iterator操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;istream_iterator&lt;!-- raw HTML omitted --&gt; in(is)&lt;/td&gt;
&lt;td&gt;in从输入流is读取类型为T的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;istream_iterator&lt;!-- raw HTML omitted --&gt; end&lt;/td&gt;
&lt;td&gt;读取类型为T的值的istream_iterator迭代器，表示尾后位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in1 == in2 或 in1!=in2&lt;/td&gt;
&lt;td&gt;in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*in&lt;/td&gt;
&lt;td&gt;返回从流中读取的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;与(*in).mem的含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++in,in++&lt;/td&gt;
&lt;td&gt;使用元素类型所定义的&amp;raquo;运算符从输入流中读取下一个值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;ostream_iterator&#34;&gt;ostream_iterator&lt;/h6&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ostream_iterator操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ostream_iterator&lt;!-- raw HTML omitted --&gt; out(os)&lt;/td&gt;
&lt;td&gt;out将类型为T的值写到输出流os中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ostream_iterator&lt;!-- raw HTML omitted --&gt; out(os,d)&lt;/td&gt;
&lt;td&gt;out将类型为T的值写到输出流os中，每个值后面都输出一个d.d指向一个空字符结尾的字符数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out = val&lt;/td&gt;
&lt;td&gt;用&amp;laquo;运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*out,++out,out++&lt;/td&gt;
&lt;td&gt;这些运算符是存在的，但不对out做任何事情。每个运算符都返回out&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;反向迭代器&#34;&gt;反向迭代器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增操作的含义变为：递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（&amp;ndash;it）会移动到下一个元素。&lt;/li&gt;
&lt;li&gt;我们可以通过调用rbegin、rend 、crbegin和crend 成员函数来获得反向迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;泛型算法结构&#34;&gt;泛型算法结构&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法锁要求的迭代器操作可以分为5个&lt;strong&gt;迭代器类别&lt;/strong&gt;(iterator category)。每个算法都会对它的每个迭代器参数指明需提供哪些迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;迭代器类别&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;输入迭代器&lt;/td&gt;
&lt;td&gt;只读，不写；单遍扫描，只能递增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输出迭代器&lt;/td&gt;
&lt;td&gt;只写，不读；单遍扫描，只能递增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前向迭代器&lt;/td&gt;
&lt;td&gt;可读写；多遍扫描，只能递增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双向迭代器&lt;/td&gt;
&lt;td&gt;可读读；多遍扫描，可增可减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机访问迭代器&lt;/td&gt;
&lt;td&gt;可读写；多遍扫描，支持全部迭代器运算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;输入迭代器&#34;&gt;输入迭代器&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以读取序列中的元素。一个输入迭代器必须支持：
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器相等和不相等运算符（==、!=）&lt;/li&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧&lt;/li&gt;
&lt;li&gt;箭头运算符（-&amp;gt;），等价于(*it).member，即，解引用迭代器，并提取对象的成员
输入迭代器只用于顺序访问。输入迭代器只能用于单遍扫描。
算法find和accumlate要求输入迭代器；而istream_iterator是一种输入迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;输出迭代器&#34;&gt;输出迭代器&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以看作输入迭代器功能上的补集——只写而不读元素。一个输出迭代器必须支持：
&lt;ul&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;解引用运算符（*）,只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）
我们只能向一个输出迭代器赋值一次。输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。
copy函数的第三个删除就是输出迭代器。ostream_iterator类型也是输出迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;前向迭代器&#34;&gt;前向迭代器&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以读写元素。前向迭代器的特点：
&lt;ul&gt;
&lt;li&gt;只能在序列中沿一个方向移动。前向迭代器支持输入和输出迭代器的操作，而且可以多次读写同一个元素。可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。
算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;双向迭代器&#34;&gt;双向迭代器：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以正向/反向读写序列中的元素。双向迭代器除了支持前向迭代器的操作外，还支持：
&lt;ul&gt;
&lt;li&gt;前置和后置递减运算符（&amp;ndash;）。
算法reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;随机访问迭代器&#34;&gt;随机访问迭代器：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;提供在常量时间内访问序列中任意元素的能力。不仅支持双向迭代器的所有功能，还支持：
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器相对位置的关系运算符（&amp;lt;、&amp;lt;=、&amp;gt;和&amp;gt;=）&lt;/li&gt;
&lt;li&gt;迭代器和一个整数值的加减运算（+、+=、-和-=）,计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置&lt;/li&gt;
&lt;li&gt;用于两个迭代器上的减法运算符（-）,得到两个迭代器的距离&lt;/li&gt;
&lt;li&gt;下标运算符（iter[n]）与*(iter[n])等价
算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;常用的容器支持的迭代器类别&#34;&gt;常用的容器支持的迭代器类别&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;只有顺序容器和关联容器才支持迭代器遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;支持的迭代器类别&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;vector&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;随机访问迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;deque&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;随机访问迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;set&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;multiset&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;map&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;multimap&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;stack、queue、priority_queue&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;算法形参模式&#34;&gt;算法形参模式&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在任何其他算法分类上，还有一组参数规范。大多数算法具有如下4种形式之一：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;alg(beg , end , other args);
alg(beg , end , dest , other args);
alg(beg , end , beg2 , other args);
alg(beg , end , beg2 , end2 , other args);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中alg是算法的名字，beg和end表示算法所操作的输入范围。dest、beg2和end2，都是迭代器参数，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;_if版本的算法&#34;&gt;_if版本的算法&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;接受一个元素的算法通常有另一个不同名字的版本，此版本接受一个谓词代替元素值。接受谓词参数的算法都有附加_if的前缀：
&lt;blockquote&gt;
&lt;p&gt;//查找输入范围中val第一次出现的位置
find(beg , end , val );
//查找第一个令pred为真的元素
find_if(beg , end , pred );
这两个算法提供了命名上的差异的版本，而非重载版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;_copy版本的算法&#34;&gt;_copy版本的算法&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认情况下，重排元素的算法将重排后的元素写回到给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。写到额外目的空间的算法都在名字后面附加一个_copy：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;//反转输入范围中元素的顺序
reverse(beg , end )
//将元素按逆序拷贝到dest
reverse_copy(beg , end , dest )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;//从v1中删除奇数元素
remove_if(v1.begin() , v1.end() , []( int i) { return i%2; } ) ;
//将偶数元素从v1拷贝到v2;v1不变
remove_copy_if(v1.begin() , v1.end() , back_inserter(v2) , []( int i) { return i%2 ;} );&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第一个调用中，从输入序列中将奇数元素删除。在第二个调用中，将非奇数元素从输入范围拷贝到v2中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关联容器&#34;&gt;关联容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是&lt;strong&gt;map&lt;/strong&gt; 和 &lt;strong&gt;set&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;关联容器支持普通容器的操作。不支持顺序容器位置相关的操作。关联容器是根据关键字存储的。
|关联容器类型 |    |
| :&amp;ndash;    | :-:  |
| &lt;strong&gt;按关键字有序保存元素&lt;/strong&gt; |  |
| map | 关联数组：保存关键字-值对 |
| set | 关键字即值，只保存关键字的容器 |
| mulitmap | 关键字可重复出现的map |
| multiset | 关键字可重复出现的set |
| &lt;strong&gt;无序集合&lt;/strong&gt; |  |
| unordered_map | 用哈希函数组织的map |
| unordered_set | 用哈希函数组织的set |
| unordered_mulitmap | 哈希组织的map；关键字可以重复出现 |
| unordered_multiset | 哈希组织的set；关键字可以重复出现 |&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有序容器的关键字类型&#34;&gt;有序容器的关键字类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的&amp;lt;运算符。所提供的操作必须在关键字类型上定义一个&lt;strong&gt;严格弱序&lt;/strong&gt;。可以讲严格弱序看作&amp;quot;小于等于&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用关键字类型的比较函数&#34;&gt;使用关键字类型的比较函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了制定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。
在定义时我们必须提供两个类型：关键字类型，以及比较操作类型——函数指针类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pair&#34;&gt;pair&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;pair是一个标准库类型，它定义在头文件utility中。&lt;/li&gt;
&lt;li&gt;一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，必须提供两个类型名，pair的数据成员将具有对应的类型。&lt;/li&gt;
&lt;li&gt;pair的数据成员是public的。两个成员分别命名为first和second。用普通的成员访问符号来访问它们。可以用make_pair来生成pair对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关联容器操作&#34;&gt;关联容器操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;关联容器额外的类型别名&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;key_value&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;此容器类型的关键字类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;mapped_type&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;每个关键字关联的类型；只适用于map&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;value_type&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对于set，与key_type相同；对于map，为pair&amp;lt;const key_type , mapped_type&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。在map中，元素是关键字-值对。即，每个元素是一个pair对象，包含一个关键字和一个关联的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;关联容器迭代器&#34;&gt;关联容器迭代器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对于map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;set的迭代器是const的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;map的下标操作&#34;&gt;map的下标操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;map和unordered_map容器提供了下标运算符和at函数。set类型不支持下标。multimap和unordered_multimap不能进行下标操作，可能有多个值与一个关键字相关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;访问元素&#34;&gt;访问元素&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;关联容器额外的类型别名&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;lower_bound和upper_bound不适用于无序容器&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;下标和at操作只适用于非const的map和unordered_map&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.find(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.count(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.lower_bound(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器，指向第一个关键字&lt;strong&gt;不小于&lt;/strong&gt;k的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.upper_bound(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器，指向第一个关键字&lt;strong&gt;大于&lt;/strong&gt;k的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.equal_range(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;对map使用find代替下标&#34;&gt;对map使用find代替下标&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对map和unordered_map类型，使用下标操作可能会导致：如果关键字未在map中，下标操作会插入一个具有给定关键字的元素。在指向知道给定关键字是否在map中，应当使用find。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;multimap或multiset中查找元素&#34;&gt;multimap或multiset中查找元素&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对于允许重复关键字的容器来说，在容器中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。可以通过以下步骤实现找到所有的映射。
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、使用count和find实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过count找到给定关键字的数量&lt;/li&gt;
&lt;li&gt;通过find得到一个迭代器指向第一个关键字&lt;/li&gt;
&lt;li&gt;循环次数为count的返回值，读取所有的映射&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、还可以通过面向迭代器的方法解决这个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果查找的元素具有容器中最大的关键字，则此关键字的upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lowe_bound返回的也是尾后迭代器。可以通过如下循环实现读取&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;for ( auto beg = x.lowe_bound(id) , end = x.upper_bound(id) ; beg != end ; ++beg )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;此处代码与count和find能完成相同的工作，但更直接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、equal_range函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;for (auto pos = x.equal_range(id) ; pos.first != pos.second ; ++pos.first)
与使用upper_bound和lower_bound功能一直，但没有使用局部变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://wangwei9160.github.io/post/linux/</link>
      <pubDate>Wed, 20 Jan 2021 00:20:24 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/linux/</guid>
      
        <description>&lt;h4 id=&#34;linux-下查看进程内的线程情况&#34;&gt;Linux 下查看进程内的线程情况&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;方法一：ps命令
&lt;blockquote&gt;
&lt;p&gt;ps -ef | grep 进程关键字
ps -T -p 线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;方法二：top命令
&lt;blockquote&gt;
&lt;p&gt;top -H -p 线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;makefile&#34;&gt;makefile&lt;/h3&gt;
&lt;h5 id=&#34;c文件到exe文件&#34;&gt;.c文件到.exe文件&lt;/h5&gt;
&lt;p&gt;hello.c &amp;ndash;&amp;gt; 预处理 -E &amp;ndash;&amp;gt; hello.i &amp;ndash;&amp;gt; 编译 -S &amp;ndash;&amp;gt; hello.s &amp;ndash;&amp;gt; 汇编 -c &amp;ndash;&amp;gt; hello.o &amp;ndash;&amp;gt; 链接 -o &amp;ndash;&amp;gt; hello
预处理 gcc -E hello.c -o helle.i
编 译    gcc -S hello.i -o hello.s
汇 编    gcc -c hello.s -o hello.o
链 接    gcc hello.o -o hello
esc iso
预处理：预处理相当于根据预处理命令组装成新的C程序，不过常以i为扩展名。
编 译：将得到的i文件翻译成汇编代码.s文件。
汇 编：将汇编文件翻译成机器指令，并打包成可重定位目标程序的o文件。该文件是二进制文件，字节编码是机器指令。
链 接：将引用的其他o文件并入到我们程序所在的o文件中，处理得到最终的可执行文件。&lt;/p&gt;
&lt;h4 id=&#34;makefile-结构&#34;&gt;makefile 结构&lt;/h4&gt;
&lt;p&gt;Makefile主要包含了五个东西：变量定义、显式规则、隐晦规则、文件指示和注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量的定义。在Makefile中我们要定义一系列的变量，变量一般是字符串。&lt;/li&gt;
&lt;li&gt;显式规则。显式规则说明了如何生成一个或者多个目标文件。显式地指出要生成的文件，文件的依赖文件，生成的命令。&lt;/li&gt;
&lt;li&gt;隐晦规则。由make自动推动的功能，隐晦的规则可以让我们比较粗糙的简略地书写Makefile，由make支持。&lt;/li&gt;
&lt;li&gt;文件指示：一个Makefile中引用另一个Makefile。&lt;/li&gt;
&lt;li&gt;注释。Makefile只有行注释，用&amp;rdquo; # &amp;ldquo;字符来表示注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;预定义变量&#34;&gt;预定义变量&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;$* 　　不包含扩展名的目标文件名称。&lt;/li&gt;
&lt;li&gt;$+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。&lt;/li&gt;
&lt;li&gt;$&amp;lt; 　　第一个依赖文件的名称。&lt;/li&gt;
&lt;li&gt;$? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。&lt;/li&gt;
&lt;li&gt;$@ 　 目标的完整名称。&lt;/li&gt;
&lt;li&gt;$^ 　　所有的依赖文件，以空格分开，不包含重复的依赖文件。&lt;/li&gt;
&lt;li&gt;$% 如果目标是归档成员，则该变量表示目标的归档成员名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;注意事项&#34;&gt;注意事项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;tab分隔，不能用空格。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;每个makefile最好加一个all&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;注释用“#”符号&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;文件指示，引用其他的makefile文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>codeforces</title>
      <link>https://wangwei9160.github.io/post/codeforces634/</link>
      <pubDate>Wed, 15 Apr 2020 01:00:00 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/codeforces634/</guid>
      
        <description>&lt;h1 id=&#34;codeforces&#34;&gt;codeforces&lt;/h1&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;A. Candies and Two Sisters&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;B. Construct the String&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;C. Two Teams Composing&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;D. Anti-Sudoku&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;E. Three Blocks Palindrome&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-idaa-candies-and-two-sistersa&#34;&gt;&lt;!-- raw HTML omitted --&gt;A. Candies and Two Sisters&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h5 id=&#34;题目&#34;&gt;题目：&lt;/h5&gt;
&lt;p&gt;There are two sisters Alice and Betty. You have n candies. You want to distribute these n candies between two sisters in such a way that:&lt;br&gt;
lice will get a (a&amp;gt;0) candies;
Betty will get b (b&amp;gt;0) candies;
each sister will get some integer number of candies;
Alice will get a greater amount of candies than Betty (i.e. a&amp;gt;b);
all the candies will be given to one of two sisters (i.e. a+b=n).
Your task is to calculate the number of ways to distribute exactly n candies between sisters in a way described above. Candies are indistinguishable.&lt;br&gt;
Formally, find the number of ways to represent n as the sum of n=a+b, where a and b are positive integers and a&amp;gt;b&amp;hellip;
You have to answer t independent test cases.&lt;/p&gt;
&lt;h4 id=&#34;题意&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;The answer is (n-1)/2&lt;/p&gt;
&lt;h4 id=&#34;代码&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		int n;cin &amp;gt;&amp;gt; n;
		cout &amp;lt;&amp;lt; (n - 1) / 2 &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;B. Construct the String&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目-1&#34;&gt;题目：&lt;/h4&gt;
&lt;p&gt;You are given three positive integers n, a and b. You have to construct a string s of length n consisting of lowercase Latin letters such that each substring of length a has exactly b distinct letters. It is guaranteed that the answer exists.&lt;br&gt;
You have to answer t independent test cases.&lt;br&gt;
Recall that the substring s[l…r] is the string $s_l$,$s_{l+1}$,…,$s_r$ and its length is r?l+1. In this problem you are only interested in substrings of length a.&lt;/p&gt;
&lt;h4 id=&#34;题意-1&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;There is no substring containing more than b distinct characters and each substring of length a contains exactly b distinct characters because of the condition b?a.&lt;/p&gt;
&lt;h4 id=&#34;代码-1&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		int n, a, b;
		cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        string ans=&amp;quot;&amp;quot;;int k=0;
		for (int i = 0; i &amp;lt; n; ++i) {
			ans += &#39;a&#39;+k;
            k = (k+1)%b;
		}
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;C. Two Teams Composing&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目-2&#34;&gt;题目：&lt;/h4&gt;
&lt;p&gt;You have n students under your control and you have to compose exactly two teams consisting of some subset of your students. Each student had his own skill, the i-th student skill is denoted by an integer ai (different students can have the same skills).&lt;br&gt;
So, about the teams. Firstly, these two teams should have the same size. Two more constraints:&lt;br&gt;
The first team should consist of students with distinct skills (i.e. all skills in the first team are unique). &lt;br&gt;
The second team should consist of students with the same skills (i.e. all skills in the second team are equal).&lt;br&gt;
Note that it is permissible that some student of the first team has the same skill as a student of the second team.
Consider some examples (skills are given): &lt;br&gt;
[1,2,3], [4,4] is not a good pair of teams because sizes should be the same;&lt;br&gt;
[1,1,2], [3,3,3] is not a good pair of teams because the first team should not contain students with the same skills;&lt;br&gt;
[1,2,3], [3,4,4] is not a good pair of teams because the second team should contain students with the same skills;&lt;br&gt;
[1,2,3], [3,3,3] is a good pair of teams;&lt;br&gt;
[5], [6] is a good pair of teams.&lt;br&gt;
Your task is to find the maximum possible size x for which it is possible to compose a valid pair of teams, where each team size is x (skills in the first team needed to be unique, skills in the second team should be the same between them). A student cannot be part of more than one team.&lt;br&gt;
You have to answer t independent test cases.&lt;/p&gt;
&lt;h4 id=&#34;题意-2&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;The number of different skills is diff.The number of skill i is $cnt_i$ .&lt;br&gt;
maxcnt = max($cnt_1$,$cnt_2$,…,$cnt_n$).&lt;br&gt;
The answer is max( min(diff?1,maxcnt) , min(diff,maxcnt?1) ).&lt;/p&gt;
&lt;h4 id=&#34;代码-2&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		int n;
		cin &amp;gt;&amp;gt; n;
		vector&amp;lt;int&amp;gt; cnt(n + 1);
		for (int i = 0; i &amp;lt; n; ++i) {
			int x;
			cin &amp;gt;&amp;gt; x;
			++cnt[x];
		}
		int mx = *max_element(cnt.begin(), cnt.end());
		int diff = n + 1 - count(cnt.begin(), cnt.end(), 0);
		cout &amp;lt;&amp;lt; max(min(mx - 1, diff), min(mx, diff - 1)) &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;D. Anti-Sudoku&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目-3&#34;&gt;题目：&lt;/h4&gt;
&lt;p&gt;You are given a correct solution of the sudoku puzzle.&lt;br&gt;
Blocks are bordered with bold black color.&lt;br&gt;
Your task is to change at most 9 elements of this field (i.e. choose some 1?i,j?9 and change the number at the position (i,j) to any other number in range [1;9]) to make it anti-sudoku. The anti-sudoku is the 9×9 field, in which:&lt;br&gt;
Any number in this field is in range [1;9];&lt;br&gt;
each row contains at least two equal elements;&lt;br&gt;
each column contains at least two equal elements;&lt;br&gt;
each 3×3 block (you can read what is the block in the link above) contains at least two equal elements.&lt;br&gt;
It is guaranteed that the answer exists.&lt;br&gt;
You have to answer t independent test cases.&lt;/p&gt;
&lt;h4 id=&#34;题意-3&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;Well, if we replace all occurrences of the number 2 with the number 1, then the initial solution will be anti-sudoku. It is easy to see that this replacement will make exactly two copies of 1 in every row, column, and block. There are also other correct approaches but I found this one the most pretty.&lt;/p&gt;
&lt;h4 id=&#34;代码-3&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		for (int i = 0; i &amp;lt; 9; ++i) {
			string s;
			cin &amp;gt;&amp;gt; s;
			for (auto &amp;amp;c : s) if (c == &#39;2&#39;) c = &#39;1&#39;;
			cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;E. Three Blocks Palindrome&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题意-4&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;The only difference between easy and hard versions is constraints.&lt;br&gt;
You are given a sequence a consisting of n positive integers.&lt;br&gt;
Let&amp;rsquo;s define a three blocks palindrome as the sequence, consisting of at most two distinct elements (let these elements are a and b, a can be equal b) and is as follows: [$\underbrace{a,a,…,a}&lt;em&gt;\text{x}$,$\underbrace{b,b,…,b}&lt;/em&gt;\text{y}$,$\underbrace{a,a,…,a}_\text{x}$]. There x,y are integers greater than or equal to 0. For example, sequences [], [2], [1,1], [1,2,1], [1,2,2,1] and [1,1,2,1,1] are three block palindromes but [1,2,3,2,1], [1,2,1,2,1] and [1,2] are not.&lt;br&gt;
Your task is to choose the maximum by length subsequence of a that is a three blocks palindrome.&lt;br&gt;
You have to answer t independent test cases.&lt;br&gt;
Recall that the sequence t is a a subsequence of the sequence s if t can be derived from s by removing zero or more elements without changing the order of the remaining elements. For example, if s=[1,2,1,3,1,2,1], then possible subsequences are: [1,1,1,1], [3] and [1,2,1,3,1,2,1], but not [3,2,3] and [1,1,1,1,2].&lt;/p&gt;
&lt;h4 id=&#34;代码-4&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    int t;cin&amp;gt;&amp;gt;t;
    while(t--){
        int n;cin&amp;gt;&amp;gt;n;
        vector&amp;lt;int&amp;gt; a(n,0);
        const int M = 200;
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; pre(M,vi(n+1));
        vector&amp;lt;vi&amp;gt; at(M);
        for(int i = 0 ; i &amp;lt; n ; i++){
            cin &amp;gt;&amp;gt;a[i];
            --a[i];
            at[a[i]].push_back(i);
        }
        for(int i = 0 ; i &amp;lt; M ; i++){
            for(int j = 0 ; j &amp;lt; n ; j++){
                pre[i][j+1] = pre[i][j] + (a[j]==i);
            }
        }
        int ans = 0;
        for(int i = 0 ; i &amp;lt; M ; i++){
            int k = pre[i][n];
            ans = max(ans,k);
            for(int j = 1 ; 2*j &amp;lt;= k ; j++){
                int bi = at[i][j-1];
                int ed = at[i][k-j];
                for(int t = 0 ; t &amp;lt; M ; t++){
                    if(t!=i){
                        ans = max(ans,j*2 + pre[t][ed]-pre[t][bi]);
                    }
                }
            }
        }
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>leetcode第184场周赛</title>
      <link>https://wangwei9160.github.io/post/leetcode184/</link>
      <pubDate>Sun, 12 Apr 2020 18:00:00 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/leetcode184/</guid>
      
        <description>&lt;h1 id=&#34;leetcode第184场周赛&#34;&gt;leetcode第184场周赛&lt;/h1&gt;
&lt;h3 id=&#34;a-id0目录a&#34;&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#a-id1%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Da&#34;&gt;数组中的字符串匹配&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id2-%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97a&#34;&gt;查询带键的排列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id3-html-%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8a&#34;&gt;HTML 实体解析器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id4%E7%BB%99-n-x-3-%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0-a&#34;&gt;给 N x 3 网格图涂色的方案数&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-id1数组中的字符串匹配a&#34;&gt;&lt;!-- raw HTML omitted --&gt;数组中的字符串匹配&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/string-matching-in-an-array/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;利用find函数直接暴力匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; stringMatching(vector&amp;lt;string&amp;gt;&amp;amp; words) {
    vector&amp;lt;string&amp;gt; ans;
    for(auto x : words){
        for(auto y : words){
            if(x == y) continue;
            if(y.find(x) != -1 ){ans.push_back(x);break;}
        }
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id2-查询带键的排列a&#34;&gt;&lt;!-- raw HTML omitted --&gt; 查询带键的排列&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/queries-on-a-permutation-with-key/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目-1&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始，排列 P=[1,2,3,&amp;hellip;,m]。&lt;/li&gt;
&lt;li&gt;对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是queries[i] 的查询结果。
请你以数组形式返回待查数组  queries 的查询结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路-1&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;模拟一遍就好了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-1&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; processQueries(vector&amp;lt;int&amp;gt;&amp;amp; queries, int m) {
    int mp[1002];
    for(int i = 0 ; i &amp;lt; m ; i++){
        mp[i] = i+1;
    }
    vector&amp;lt;int&amp;gt; ans;
    for(auto x : queries){
        if(mp[0] == x) {ans.push_back(0);continue;}
        int j = m-1;
        while( j &amp;gt; 0 &amp;amp;&amp;amp; mp[j] != x) {j--;}
        ans.push_back(j);
        for(int k = j ; k &amp;gt; 0 ; k--){
            mp[k] = mp[k-1];
        }
        mp[0] = x;
        
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id3-html-实体解析器a&#34;&gt;&lt;!-- raw HTML omitted --&gt; HTML 实体解析器&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/html-entity-parser/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目-2&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。
HTML 里这些特殊字符和它们对应的字符实体包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号：字符实体为 &amp;quot; ，对应的字符是 &amp;quot; 。&lt;/li&gt;
&lt;li&gt;单引号：字符实体为 &#39; ，对应的字符是 &#39; 。&lt;/li&gt;
&lt;li&gt;与符号：字符实体为 &amp;amp; ，对应对的字符是 &amp;amp; 。&lt;/li&gt;
&lt;li&gt;大于号：字符实体为 &amp;gt; ，对应的字符是 &amp;gt; 。&lt;/li&gt;
&lt;li&gt;小于号：字符实体为 &amp;lt; ，对应的字符是 &amp;lt; 。&lt;/li&gt;
&lt;li&gt;斜线号：字符实体为 ⁄ ，对应的字符是 / 。
给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路-2&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;利用replace函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-2&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;def entityParser(self, text: str) -&amp;gt; str:
    text = text.replace(&#39;&amp;amp;quot;&#39;,&#39;&amp;quot;&#39;)
    text = text.replace(&#39;&amp;amp;apos;&#39;,&#39;\&#39;&#39;)
    text = text.replace(&#39;&amp;amp;amp;&#39;,&#39;&amp;amp;&#39;)
    text = text.replace(&#39;&amp;amp;gt;&#39;,&#39;&amp;gt;&#39;)
    text = text.replace(&#39;&amp;amp;lt;&#39;,&#39;&amp;lt;&#39;)
    text = text.replace(&#39;&amp;amp;frasl;&#39;,&#39;/&#39;)
    return text
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id4给-n-x-3-网格图涂色的方案数-a&#34;&gt;&lt;!-- raw HTML omitted --&gt;给 N x 3 网格图涂色的方案数 &lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;题目-3&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;你有一个 n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。
给你网格图的行数 n 。
请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路-3&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;初始化第一行的所有状态
接下来计算每一行的所有状态的出现的次数
条件（相同水平边或者垂直边的格子颜色不同）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-3&#34;&gt;代码:&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;long long dp[5002][3][3][3];
const int mod = 1e9+7;
int numOfWays(int n) {
    for(int i=0;i&amp;lt;3;i++)for(int j=0;j&amp;lt;3;j++)for(int k=0;k&amp;lt;3;k++)if(i!=j&amp;amp;&amp;amp;j!=k) dp[1][i][j][k]=1;
    for(int p=2;p&amp;lt;=n;p++){
        for(int i=0;i&amp;lt;3;i++)
            for(int j=0;j&amp;lt;3;j++)
                for(int k=0;k&amp;lt;3;k++)
                    for(int ii=0;ii&amp;lt;3;ii++)
                        for(int jj=0;jj&amp;lt;3;jj++)
                            for(int kk=0;kk&amp;lt;3;kk++)
                                if(i!=j&amp;amp;&amp;amp;j!=k&amp;amp;&amp;amp;ii!=i&amp;amp;&amp;amp;jj!=j&amp;amp;&amp;amp;kk!=k) 
                                    (dp[p][i][j][k] += dp[p-1][ii][jj][kk]) %= mod;
    }
    long long ans =0;
    for(int i=0;i&amp;lt;3;i++)for(int j=0;j&amp;lt;3;j++)for(int k=0;k&amp;lt;3;k++)if(i!=j&amp;amp;&amp;amp;j!=k) ans+=dp[n][i][j][k];
    ans%=mod;
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;#a-id0%E7%9B%AE%E5%BD%95a&#34;&gt;回到目录&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
