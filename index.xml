<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Awei</title>
    <link>https://wangwei9160.github.io/</link>
    <description>Recent content on Awei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Mar 2021 14:36:36 +0800</lastBuildDate>
    
        <atom:link href="https://wangwei9160.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>动态内存</title>
      <link>https://wangwei9160.github.io/post/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 17 Mar 2021 14:36:36 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
      
        <description>&lt;h2 id=&#34;动态内存&#34;&gt;动态内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局对象在程序启动时分配，在程序结束时销毁；局部自动对象，当进入其定义所在的程序块时被创建，在离开块时销毁；局部static对象在第一次使用前分配，在程序结束时销毁。&lt;/li&gt;
&lt;li&gt;动态分配的对象的生存期与他们在哪里创建是无关的，只有当显式地被释放时，这些对象才销毁。&lt;/li&gt;
&lt;li&gt;标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被销毁时，指向它的只能指针可以确保自动地释放它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智能指针&#34;&gt;智能指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态内存的管理是通过&lt;strong&gt;new&lt;/strong&gt;和&lt;strong&gt;delete&lt;/strong&gt;来完成的。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;new&lt;/strong&gt;：在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;delete&lt;/strong&gt;：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标准库提供了两种&lt;strong&gt;智能指针&lt;/strong&gt;类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放锁指向的对象。两种智能指针的区别在于管理底层指针的方式：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;shared_ptr&lt;/strong&gt;：允许多个指针指向同一个对象。在最后一个shared_ptr析构的时候，内存才会释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;：&amp;lsquo;独占&#39;所指向的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weak_ptr&lt;/strong&gt;：弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shared_ptr&#34;&gt;shared_ptr&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;shared_ptr和unique_ptr都支持的操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;shared_ptr&amp;lt; T&amp;gt; sp、unique_ptr&amp;lt; T&amp;gt; sp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空智能指针，可以指向类型为T的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;将p用作一个条件判断，若p指向一个对象，则为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;*p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解引用p，获得它指向的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p-&amp;gt;mem&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;等价于(*p).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p.get()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回p中保存的指针。若智能指针释放了其对象，返回的指针所指向的对象也就消失了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;swap(p,q)、p.swap(q)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;交换p和q中的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;shared_ptr独有的操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;make_shared&amp;lt; T&amp;gt;(args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;shared_ptr&amp;lt; T&amp;gt;p(q)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;p是shared_ptr类型q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p = q&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;p和q都是shared_ptr类型，保存的指针必须能相互转换。此操作会递减p的引用计数，递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p.unique()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;若p.use_count()为1，返回true；否则返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;p.use_count()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回与p共享对象的智能指针数量；主要用于调试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最安全的分配和使用动态内存的方法是调用make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。通常用auto定义一个对象来保存make_shared_ptr的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个shared_ptr都有一个关联的计数器，&lt;strong&gt;引用计数&lt;/strong&gt;。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。&lt;/li&gt;
&lt;li&gt;shared_ptr类会自动销毁此独享。它是通过另一个特殊的成员函数——&lt;strong&gt;析构函数&lt;/strong&gt;完成销毁工作的。类似于构造函数，每个类都有一个析构函数。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。&lt;/li&gt;
&lt;li&gt;当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;使用动态生存期的资源的类&#34;&gt;使用动态生存期的资源的类&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;程序使用动态内存出于以下三种原因之一：
1、程序不知道自己需要使用多少对象
2、程序不知道所需对象的准确类型
3、程序需要在多个对象间共享数据
容器类是出于第一种原因而使用动态内存的典型例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直接管理内存&#34;&gt;直接管理内存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;new、delete&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;相比于智能指针，直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用new动态分配和初始化对象&#34;&gt;使用new动态分配和初始化对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针。&lt;/li&gt;
&lt;li&gt;默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。&lt;/li&gt;
&lt;li&gt;可以使用直接初始化方法来初始化一个动态分配的对象，也可以使用传统的构造方式（圆括号）。在新标准下，也可以使用列表初始化（花括号）。&lt;/li&gt;
&lt;li&gt;如果提供一个括号保卫的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。当括号中仅有一个单一初始化器时才可以使用auto。&lt;/li&gt;
&lt;li&gt;用new分配const对象是合法的。虽然const对象的值不能被改变，但它本身是可以被销毁的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存耗尽&#34;&gt;内存耗尽&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。
&lt;blockquote&gt;
&lt;p&gt;//如果分配失败，new返回一个空指针
int *p1 = new int;//如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int;//如果分配失败,new返回一个空指针
这种形式的new为&lt;strong&gt;定位new&lt;/strong&gt;(placement new)。定位new表达式允许我们向new传递额外的参数。如果nothrow传递给new，试图告诉它不能抛出异常。如果这种形式的new不能分配所需要的内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;释放动态内存&#34;&gt;释放动态内存&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为了防止内存耗尽，通过&lt;strong&gt;delete表达式&lt;/strong&gt;来将内存归还给系统。delete表达式接受一个指针，指向我们想要释放的对象。delete表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;动态内存的管理&#34;&gt;动态内存的管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用new和delete管理动态内存常见的三个问题：
1、忘记delete内存。
2、使用已经释放掉的对象。
3、同一块内存释放两次。
只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;空悬指针&#34;&gt;空悬指针&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在delete之后，指针就变成&lt;strong&gt;空悬指针&lt;/strong&gt;(dangling pointer)，指向一块曾经保存数据对象但现在已经无效的内存的指针。&lt;/li&gt;
&lt;li&gt;未初始化指针的所有缺点空悬指针也有。避免空悬指针的问题：在指针即将要离开其作用域之前释放掉它所关联的内存。这样，在指针关联的内存被释放掉之后，就没有机会继续使用指针了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;动态内存的问题&#34;&gt;动态内存的问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重置指针的方法只对这个指针有效，对其他任何仍指向（已释放）内存的指针是没有作用的。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Git</title>
      <link>https://wangwei9160.github.io/post/git/</link>
      <pubDate>Sat, 13 Mar 2021 13:27:30 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/git/</guid>
      
        <description>&lt;h1 id=&#34;github-repository&#34;&gt;github repository&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用github创建仓库时的步骤，windows&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建仓库&#34;&gt;创建仓库&lt;/h2&gt;
&lt;h3 id=&#34;1-new-repository&#34;&gt;1、 new repository&lt;/h3&gt;
&lt;p&gt;在github界面选择new一个repository&lt;/p&gt;
&lt;h3 id=&#34;2设置repository信息&#34;&gt;2、设置Repository信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设置Repository name、Description（可不填）&lt;/li&gt;
&lt;li&gt;为初始化仓库的信息文件。（可不添加）&lt;/li&gt;
&lt;li&gt;Add a README file ： 添加说明文件MEADME.md。直接使用Description中的内容作为文件的内容，也可以在创建仓库后仓库主界面选择Add file，Create new file中添加MEADME.md&lt;/li&gt;
&lt;li&gt;Add .gitignore ： 在使用git的过程中有些日志文件、临时文件、编译产生的中间文件不需要纳入git的管理，可以再gitignore中列出要忽略的文件模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3create-repository&#34;&gt;3、Create repository&lt;/h3&gt;
&lt;p&gt;点击Create repository&lt;/p&gt;
&lt;h2 id=&#34;4进到repository主界面&#34;&gt;4、进到repository主界面&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建结束自动跳转(大概会github不崩的话)&lt;/li&gt;
&lt;li&gt;可以通过访问 github.com/xxxx/name
xxxx 是自己的github用户名，name是repository的name&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5点击code-查看信息&#34;&gt;5、点击code 查看信息&lt;/h3&gt;
&lt;p&gt;点击code 可以查看到https、ssh、github CLI&lt;/p&gt;
&lt;h3 id=&#34;6在本地创建一个目录&#34;&gt;6、在本地创建一个目录&lt;/h3&gt;
&lt;p&gt;提前部署好git&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自己的主机上想要的位置存放这个仓库的更新内容以及推送更新，在响应的位置上右键选择Git Bash Here.&lt;/li&gt;
&lt;li&gt;git clone &lt;a href=&#34;https://github.com/xxxx/name.git&#34;&gt;https://github.com/xxxx/name.git&lt;/a&gt;
xxxx 是github用户名，name是repository的name&lt;/li&gt;
&lt;li&gt;cd name
通过cd 进入到本地的仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-添加想添加的文件&#34;&gt;7、 添加想添加的文件&lt;/h3&gt;
&lt;h3 id=&#34;8-使用git&#34;&gt;8、 使用git&lt;/h3&gt;
&lt;p&gt;通过cd进入到name目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cd xx/xx/name&lt;/li&gt;
&lt;li&gt;git add .&lt;/li&gt;
&lt;li&gt;git commit -m &amp;ldquo;new&amp;rdquo;&lt;/li&gt;
&lt;li&gt;git push -u origin main
在新建仓库分支是main。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;维护repository&#34;&gt;维护repository&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;git add .&lt;/li&gt;
&lt;li&gt;git commit -m &amp;ldquo;new&amp;rdquo;&lt;/li&gt;
&lt;li&gt;git push -u origin main
在新建仓库分支是main。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Allocator</title>
      <link>https://wangwei9160.github.io/post/allocator/</link>
      <pubDate>Fri, 12 Mar 2021 11:34:39 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/allocator/</guid>
      
        <description>&lt;h2 id=&#34;allocator&#34;&gt;allocator&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;标准库allocator类定义在头文件memory中，它帮助我们将内存分配和独享构造分离开来。提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。&lt;/li&gt;
&lt;li&gt;当一个allocator对象分配内存时，allocator会根据给定的对象类型来确定恰当的内存大小和对齐位置：
&lt;blockquote&gt;
&lt;p&gt;allocator&lt;!-- raw HTML omitted --&gt; alloc;            //可以分配string的allocator对象
auto const p = alloc.allocate(n);   //分配n个未初始化的string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;写法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;allocator &amp;lt; T &amp;gt; a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;定义了一个名为a的allocator对象，为类型T的对象分配内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.allocate(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;分配一段原始的、未构造的内存，保存n个类型为T的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.deallocate(p,n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;释放从T*指针p中地址开始的内存，这块内存保存了n个类为T的对象；T必须是一个先前由allocate返回的指针，n必须是p创建时所要求的大小。在调用之前必须对每个这块内存中创建的对象调用destory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.construct(p,args)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;T*类型指针p，指向原始内存，arg被传递给类型为T的构造函数，用来构造一个对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;a.destroy(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;T*类型指针p，对p指向的对象进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;allocator&lt;!-- raw HTML omitted --&gt; alloc;         &lt;br&gt;
auto const p = alloc.allocate(n);&lt;br&gt;
auto q = p ;                      // q指向最后构造的元素之后的位置&lt;br&gt;
alloc.construct(q++);             // *q为空字符串  &lt;br&gt;
alloc.construct(q++, 10 , &amp;lsquo;c&amp;rsquo;);   //*q为cccccccccc&lt;br&gt;
alloc.construct(q++ , &amp;ldquo;hi&amp;rdquo; ) ;    //*q为hi!&lt;br&gt;
while (q != p)  alloc.destory(&amp;ndash;q); // 释放真正构造的string
alloc.deallocator(p,n);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;预计自己写的allocator类&#34;&gt;预计自己写的allocator类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;大体思路&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;allocate&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;默认生成一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;allocate(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;生成多个,n&amp;gt;=0,特判0的情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dellocate(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;默认释放一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dellocate(p,n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;释放多个,n&amp;gt;=0,特判0的情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;构造一个默认为空的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p,T&amp;amp;)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;创建一个对象，方式是调用T的有参构造函数，参数为传过来的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p,T)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;创建一个对象，方式是调用T的有参构造函数，参数为传过来的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;construct(p,Args)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;带参数列表的构造&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy(p)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对p所指的对象进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy(p,n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对p所指的对象进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy(p1,p2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对p1到p2的空间进行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>Word</title>
      <link>https://wangwei9160.github.io/post/word/</link>
      <pubDate>Mon, 01 Mar 2021 11:53:30 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/word/</guid>
      
        <description>&lt;h1 id=&#34;英语单词-or-小短文&#34;&gt;英语单词 or 小短文&lt;/h1&gt;
&lt;h3 id=&#34;210301&#34;&gt;21.03.01&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>STL</title>
      <link>https://wangwei9160.github.io/post/stl/</link>
      <pubDate>Sun, 28 Feb 2021 17:47:04 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/stl/</guid>
      
        <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;内容参考自c++ primer 第五版和网上的一些资料。仅供自己学习参考使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;自己的轻量级stl库&#34;&gt;自己的轻量级STL库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只实现部分STL库文件，增加对STL库的理解。会逐步进行完善。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;size_t ： 定义在cstdef头文件中，是一个与机器相关的unsigned类型，其大小足以存储内存中对象的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，查找int类型的vector中是否包含一个特定值，可以使用find函数。
&lt;blockquote&gt;
&lt;p&gt;int val = 1;
auto result = find( vec.cbegin() , vec.cend () , val );&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;decltype:如果明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，假设两个函数返回类型都是string::size_type，并且各有两个const string&amp;amp;类型的形参，此时我们可以便携第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;string::size_type sumLength(const string&amp;amp; , const string&amp;amp;);
string::size_type largerLength(const string&amp;amp; , const string&amp;amp;);
decltype(sumLength) *getFcn(const string&amp;amp;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将decltype作用于某个函数时，它返回函数类型而不是指针类型。因此，我们显示地加上*以表示我们需要返回指针，而不是函数本身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;at成员函数 ： at成员函数类似于下标运算符，但如果下标越界，at会抛出一个out_of_range异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顺序容器包括：&lt;strong&gt;vector,deque,list,forward_list,array,string&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;string&lt;/strong&gt;和&lt;strong&gt;vector&lt;/strong&gt;。由于元素是连续存储的，由元素的下标来计算其地址是非常快的。为保持连续存储，添加一个元素可能要分配额外的存储空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;list&lt;/strong&gt;和&lt;strong&gt;forward_list&lt;/strong&gt;。是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为访问一个元素，只能遍历整个容器。与vector,deque,array相比，这两个容器的额外内存开销也很大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deque&lt;/strong&gt;。与vector和string类似，deque支持快速的随机访问，中间位置添加或删除元素的代价很大。但是，两端添加或删除元素很快，与list和forward_list的速度相当。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assign&lt;/strong&gt;操作 （仅顺序容器）。允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。
&lt;blockquote&gt;
&lt;p&gt;list&lt;!-- raw HTML omitted --&gt; names;
vector&amp;lt;const char*&amp;gt; oldstyle;
names.assign(oldstyle.cbegin(),oldstyle.cend ());
list&lt;!-- raw HTML omitted --&gt; slist1(1);//1个元素，为空string。
slist1.assign(10,&amp;ldquo;Hiya!&amp;quot;);//10个元素，每个都是&amp;quot;Hiya!&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;顺序容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;vector&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;deque&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双端队列。支持快速随机访问。在头尾位置插入/伤处速度很快。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;forward_list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;单向链表。只支持单向顺序访问。在链表中任何位置进行插入/删除操作速度都很快。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;array&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;固定大小数组。支持快速随机访问。不能添加或删除元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;容器操作&#34;&gt;容器操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型别名&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;此容器类型的迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_iterator&lt;/td&gt;
&lt;td&gt;可以读取元素，但不能修改元素的迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;size_type&lt;/td&gt;
&lt;td&gt;无符号整数类型，足够保存此种容器类型最大可能容器的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;difference_type&lt;/td&gt;
&lt;td&gt;带符号类型，足够保存两个迭代器之间的距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;value_type&lt;/td&gt;
&lt;td&gt;元素类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reference&lt;/td&gt;
&lt;td&gt;元素的左值类型；与value_type&amp;amp;含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_reference&lt;/td&gt;
&lt;td&gt;元素的const左值类型（即，const value_type&amp;amp;）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;构造函数&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C c&lt;/td&gt;
&lt;td&gt;默认构造函数，构造空容器(array有单独的构造函数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c1(c2)&lt;/td&gt;
&lt;td&gt;构造c2的拷贝c1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c(b,e)&lt;/td&gt;
&lt;td&gt;构造c，将迭代器 b 和 e 指定的范围内的元素拷贝到t(array不支持)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c(a,b,c,d&amp;hellip;)&lt;/td&gt;
&lt;td&gt;列表初始化t&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;赋值与swap&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c1 = c2&lt;/td&gt;
&lt;td&gt;将c1中的元素替换为c2中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c1 = {a,b,c&amp;hellip;}&lt;/td&gt;
&lt;td&gt;将c1中的元素替换为列表中元素(不适用于array)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a.swap(b)&lt;/td&gt;
&lt;td&gt;交换a和b的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;swap(a,b)&lt;/td&gt;
&lt;td&gt;a.swap(b)等价&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.size()&lt;/td&gt;
&lt;td&gt;c中元素的数目(不支持forward_list)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.max_size()&lt;/td&gt;
&lt;td&gt;c可保存的最大元素数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.empty()&lt;/td&gt;
&lt;td&gt;若c中存储了元素，返回false，否则返回true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;添加/删除元素(不适用于array)&lt;/th&gt;
&lt;th&gt;不同容器中，操作的接口不同&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.insert(args)&lt;/td&gt;
&lt;td&gt;将args中的元素进行拷贝进c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.emplace(inits)&lt;/td&gt;
&lt;td&gt;使用inits构造c中的一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.erase(args)&lt;/td&gt;
&lt;td&gt;除args指定的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.clear()&lt;/td&gt;
&lt;td&gt;删除c中的所有元素，返回void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关系运算符&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;==,!=&lt;/td&gt;
&lt;td&gt;所有容器都支持相等(不等)运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;关系运算符(无序关联容器不支持)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;获取迭代器&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.begin(),c.end ()&lt;/td&gt;
&lt;td&gt;返回指向c的首元素和尾元素之后位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.cbegin(),c.cend ()&lt;/td&gt;
&lt;td&gt;返回const_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;反向容器的额外成员&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;reverse_iterator&lt;/td&gt;
&lt;td&gt;按逆序寻址元素的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_reverse_iterator&lt;/td&gt;
&lt;td&gt;不能修改元素的逆序迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.rbegin(),c.rend ()&lt;/td&gt;
&lt;td&gt;返回指向c的尾元素和首元素之前位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.crbegin(),c.crend ()&lt;/td&gt;
&lt;td&gt;返回const_reverse_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;vector对象是如何增长的&#34;&gt;vector对象是如何增长的:&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器大小管理操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;shrink_to_fit只适用于vector、string和deque&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;capacity和reserve只适用于vector和string&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.shrink_to_fit&lt;/td&gt;
&lt;td&gt;将capacity()减少为与size()相同大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.capacity()&lt;/td&gt;
&lt;td&gt;不重新分配内存空间的话，c可以保存多少元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.reserve(n)&lt;/td&gt;
&lt;td&gt;分配至少能容纳n个元素的内存空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;capacity和size。容器的size是指已经保存的元素的数目；而capacity则是不分配新的内存空间的前提下它最多可以保存多少元素。在标准库的实现中，每次添加1个元素，共添加24个元素，会使capacity变为32.&lt;/li&gt;
&lt;li&gt;调用shrink_to_fit只是一个请求，标准库并不保证退还内存。&lt;/li&gt;
&lt;li&gt;每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当&lt;strong&gt;迫不得已&lt;/strong&gt;时才可以分配新的内存空间。所有实现都应遵循一个原则：确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector，所花费的时间不能超过n的常数倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。&lt;strong&gt;适配器&lt;/strong&gt;是标准库中的一个通用概念。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。&lt;/li&gt;
&lt;li&gt;默认情况下，stack和queue是基于&lt;strong&gt;deque&lt;/strong&gt;实现的，priority_queue是在&lt;strong&gt;vector&lt;/strong&gt;基础上实现的。&lt;/li&gt;
&lt;li&gt;对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array直伤。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;泛型算法&#34;&gt;泛型算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为弄清算法如何用于不同类型的容器，分析find是如何在未排序的元素序列中查找一个指定元素。
&lt;ol&gt;
&lt;li&gt;访问序列中的首元素。&lt;/li&gt;
&lt;li&gt;比较此元素与我们要查找的值。&lt;/li&gt;
&lt;li&gt;如果此元素与我们要查找的值匹配，find返回标识此元素的值。&lt;/li&gt;
&lt;li&gt;否则，find前进到下一个元素，重复执行步骤2和3.&lt;/li&gt;
&lt;li&gt;如果到达序列尾部，find应停止。&lt;/li&gt;
&lt;li&gt;如果find到达序列尾部，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这些步骤都不需要依赖于容器所保存的元素类型。因此，只要有一个迭代器就可以用来访问元素，find就完全不依赖于容器的类型。&lt;/li&gt;
&lt;li&gt;迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。只需要迭代器就可以进行除了上述第二步之外的所有操作。但第二步中我们需要使用元素类型上的操作，find需要用到元素类型的==运算符完成每个元素与给定值的比较。在大多数的算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;谓词&#34;&gt;谓词&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的的谓词分为两类：&lt;strong&gt;一元谓词&lt;/strong&gt;(unary predicate，意味着他们只接受单一参数)和&lt;strong&gt;二元谓词&lt;/strong&gt;(binary prediacate,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。
&lt;ul&gt;
&lt;li&gt;接受一个二元谓词参数的sort版本用这个谓词代替&amp;lt;来比较元素。我们提供给sort的谓词必须满足在关键字类型上定义一个&lt;strong&gt;严格弱序&lt;/strong&gt;(strict weak ordering)。可以讲严格弱序看做&#39;&amp;lsquo;小于等于&amp;rsquo;&#39;,虽然实际上定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：
&lt;ul&gt;
&lt;li&gt;两个关键字不能同时“小于等于”对方.&lt;/li&gt;
&lt;li&gt;如果k1&amp;quot;小于等于&amp;quot;k2,且k2&amp;quot;小于等于&amp;quot;k3,那么k1必须&amp;quot;小于等于&amp;quot;k3.&lt;/li&gt;
&lt;li&gt;如果存在两个关键字，任何一个都不&amp;quot;小于等于&amp;quot;另一个,那么我们称这两个关键字是&amp;quot;等价&amp;quot;的.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;我们可以向一个算法传递任何类型的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以便携代码e(args)，其中args是一个逗号分隔的一个或多个参数的列表。&lt;/li&gt;
&lt;li&gt;一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：
&lt;blockquote&gt;
&lt;p&gt;[ capture list ] ( parameter list ) -&amp;gt; return type { function body }
auto f = [] {return 42;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;参数绑定&#34;&gt;参数绑定&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。&lt;/li&gt;
&lt;li&gt;如果lambda的捕获列表为空，通常可以用函数来代替它。但是对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。例如，我们用在find_if调用中的lambda比较一个string和一个给定大小可以使用
&lt;blockquote&gt;
&lt;p&gt;bool check_size(const string &amp;amp;s,string::size_type sz){
return s.size() &amp;gt;= sz;
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;但是，我们不用能这个函数作为find_if的一个参数。find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;标准库bind函数&#34;&gt;标准库bind函数&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;我们可以使用bind函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来&amp;quot;适应&amp;quot;原对象的参数列表。调用bind的一般形式为
&lt;ul&gt;
&lt;li&gt;auto newCallable = bind(callable , arg_list)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是&amp;quot;占位符&amp;rdquo;，表示newCallable的参数，它们占据了传递给newCallable的参数的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;bind的参数&#34;&gt;bind的参数：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;auto g = bind(f , a , b , _2 , c , _1);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个分别被绑定在给定值a、b和c上。&lt;/li&gt;
&lt;li&gt;传递给g的参数按位置绑定到占位符。第一个参数绑定到_1，第二个参数绑定到_2.因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个 参数将被传递给f作为第三个参数。这个bind调用会将
&lt;ul&gt;
&lt;li&gt;g(_1 , _2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;映射为
&lt;ul&gt;
&lt;li&gt;f(a , b, _2 , c, _1);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用g(X , Y ) 会调用 f(a, b, X, c, Y)&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;例如用bind重排参数顺序&#34;&gt;例如用bind重排参数顺序：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;按单词长度由短到长排序
sort(words.begin(),words.end (), isShorter);
按单词长度由长到短排序
sort(words.begin(),words.end (), bind(isShorter, _2, _1));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;标准库在iterator中定义了额外几种迭代器。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入迭代器（insert iterator）&lt;/strong&gt;：这些迭代器被绑定在一个容器上，可用来向容器插入元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流迭代器（stream iterator）&lt;/strong&gt;：这些迭代器被绑定到输入或输出流上，可用来遍历所相关联的io流。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向迭代器（reverse iterator）&lt;/strong&gt;：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动迭代器（move iterator）&lt;/strong&gt;：这些专用的迭代器不是拷贝其中的元素，而是移动它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;插入迭代器&#34;&gt;插入迭代器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入器是一种迭代器适配器。它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入器有三种类型，差异在于元素插入的位置：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;back_inserter&lt;/strong&gt;创建一个使用push_back的迭代器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;front_inserter&lt;/strong&gt;创建一个使用push_front的迭代器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inserter&lt;/strong&gt;创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
当调用inserter(c , iter)时，我们得到一个迭代器，接下来使用它时，会讲元素插入到iter原来指向的元素之前的位置。即，如果it是由inserter生成的迭代器，则赋值语句：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;*it = val;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与下面的语句效果一样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;it = c.insert(it, val);
++it;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;iostream迭代器&#34;&gt;iostream迭代器&lt;/h5&gt;
&lt;p&gt;虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器，istream_iterator读取输入流，ostream_iterator向一个输出流写数据。&lt;/p&gt;
&lt;h6 id=&#34;istream_iterator&#34;&gt;istream_iterator&lt;/h6&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;istream_iterator操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;istream_iterator&lt;!-- raw HTML omitted --&gt; in(is)&lt;/td&gt;
&lt;td&gt;in从输入流is读取类型为T的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;istream_iterator&lt;!-- raw HTML omitted --&gt; end&lt;/td&gt;
&lt;td&gt;读取类型为T的值的istream_iterator迭代器，表示尾后位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in1 == in2 或 in1!=in2&lt;/td&gt;
&lt;td&gt;in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*in&lt;/td&gt;
&lt;td&gt;返回从流中读取的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;与(*in).mem的含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++in,in++&lt;/td&gt;
&lt;td&gt;使用元素类型所定义的&amp;raquo;运算符从输入流中读取下一个值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;ostream_iterator&#34;&gt;ostream_iterator&lt;/h6&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ostream_iterator操作&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ostream_iterator&lt;!-- raw HTML omitted --&gt; out(os)&lt;/td&gt;
&lt;td&gt;out将类型为T的值写到输出流os中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ostream_iterator&lt;!-- raw HTML omitted --&gt; out(os,d)&lt;/td&gt;
&lt;td&gt;out将类型为T的值写到输出流os中，每个值后面都输出一个d.d指向一个空字符结尾的字符数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out = val&lt;/td&gt;
&lt;td&gt;用&amp;laquo;运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*out,++out,out++&lt;/td&gt;
&lt;td&gt;这些运算符是存在的，但不对out做任何事情。每个运算符都返回out&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;反向迭代器&#34;&gt;反向迭代器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增操作的含义变为：递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（&amp;ndash;it）会移动到下一个元素。&lt;/li&gt;
&lt;li&gt;我们可以通过调用rbegin、rend 、crbegin和crend 成员函数来获得反向迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;泛型算法结构&#34;&gt;泛型算法结构&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法锁要求的迭代器操作可以分为5个&lt;strong&gt;迭代器类别&lt;/strong&gt;(iterator category)。每个算法都会对它的每个迭代器参数指明需提供哪些迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;迭代器类别&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;输入迭代器&lt;/td&gt;
&lt;td&gt;只读，不写；单遍扫描，只能递增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输出迭代器&lt;/td&gt;
&lt;td&gt;只写，不读；单遍扫描，只能递增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前向迭代器&lt;/td&gt;
&lt;td&gt;可读写；多遍扫描，只能递增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双向迭代器&lt;/td&gt;
&lt;td&gt;可读读；多遍扫描，可增可减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机访问迭代器&lt;/td&gt;
&lt;td&gt;可读写；多遍扫描，支持全部迭代器运算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;输入迭代器&#34;&gt;输入迭代器&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以读取序列中的元素。一个输入迭代器必须支持：
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器相等和不相等运算符（==、!=）&lt;/li&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧&lt;/li&gt;
&lt;li&gt;箭头运算符（-&amp;gt;），等价于(*it).member，即，解引用迭代器，并提取对象的成员
输入迭代器只用于顺序访问。输入迭代器只能用于单遍扫描。
算法find和accumlate要求输入迭代器；而istream_iterator是一种输入迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;输出迭代器&#34;&gt;输出迭代器&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以看作输入迭代器功能上的补集——只写而不读元素。一个输出迭代器必须支持：
&lt;ul&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;解引用运算符（*）,只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）
我们只能向一个输出迭代器赋值一次。输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。
copy函数的第三个删除就是输出迭代器。ostream_iterator类型也是输出迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;前向迭代器&#34;&gt;前向迭代器&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以读写元素。前向迭代器的特点：
&lt;ul&gt;
&lt;li&gt;只能在序列中沿一个方向移动。前向迭代器支持输入和输出迭代器的操作，而且可以多次读写同一个元素。可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。
算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;双向迭代器&#34;&gt;双向迭代器：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;可以正向/反向读写序列中的元素。双向迭代器除了支持前向迭代器的操作外，还支持：
&lt;ul&gt;
&lt;li&gt;前置和后置递减运算符（&amp;ndash;）。
算法reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;随机访问迭代器&#34;&gt;随机访问迭代器：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;提供在常量时间内访问序列中任意元素的能力。不仅支持双向迭代器的所有功能，还支持：
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器相对位置的关系运算符（&amp;lt;、&amp;lt;=、&amp;gt;和&amp;gt;=）&lt;/li&gt;
&lt;li&gt;迭代器和一个整数值的加减运算（+、+=、-和-=）,计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置&lt;/li&gt;
&lt;li&gt;用于两个迭代器上的减法运算符（-）,得到两个迭代器的距离&lt;/li&gt;
&lt;li&gt;下标运算符（iter[n]）与*(iter[n])等价
算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;常用的容器支持的迭代器类别&#34;&gt;常用的容器支持的迭代器类别&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;只有顺序容器和关联容器才支持迭代器遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;支持的迭代器类别&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;vector&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;随机访问迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;deque&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;随机访问迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;set&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;multiset&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;map&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;multimap&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;双向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;stack、queue、priority_queue&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;算法形参模式&#34;&gt;算法形参模式&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在任何其他算法分类上，还有一组参数规范。大多数算法具有如下4种形式之一：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;alg(beg , end , other args);
alg(beg , end , dest , other args);
alg(beg , end , beg2 , other args);
alg(beg , end , beg2 , end2 , other args);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中alg是算法的名字，beg和end表示算法所操作的输入范围。dest、beg2和end2，都是迭代器参数，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;_if版本的算法&#34;&gt;_if版本的算法&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;接受一个元素的算法通常有另一个不同名字的版本，此版本接受一个谓词代替元素值。接受谓词参数的算法都有附加_if的前缀：
&lt;blockquote&gt;
&lt;p&gt;//查找输入范围中val第一次出现的位置
find(beg , end , val );
//查找第一个令pred为真的元素
find_if(beg , end , pred );
这两个算法提供了命名上的差异的版本，而非重载版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;_copy版本的算法&#34;&gt;_copy版本的算法&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认情况下，重排元素的算法将重排后的元素写回到给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。写到额外目的空间的算法都在名字后面附加一个_copy：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;//反转输入范围中元素的顺序
reverse(beg , end )
//将元素按逆序拷贝到dest
reverse_copy(beg , end , dest )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;//从v1中删除奇数元素
remove_if(v1.begin() , v1.end() , []( int i) { return i%2; } ) ;
//将偶数元素从v1拷贝到v2;v1不变
remove_copy_if(v1.begin() , v1.end() , back_inserter(v2) , []( int i) { return i%2 ;} );&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第一个调用中，从输入序列中将奇数元素删除。在第二个调用中，将非奇数元素从输入范围拷贝到v2中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关联容器&#34;&gt;关联容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是&lt;strong&gt;map&lt;/strong&gt; 和 &lt;strong&gt;set&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;关联容器支持普通容器的操作。不支持顺序容器位置相关的操作。关联容器是根据关键字存储的。
|关联容器类型 |    |
| :&amp;ndash;    | :-:  |
| &lt;strong&gt;按关键字有序保存元素&lt;/strong&gt; |  |
| map | 关联数组：保存关键字-值对 |
| set | 关键字即值，只保存关键字的容器 |
| mulitmap | 关键字可重复出现的map |
| multiset | 关键字可重复出现的set |
| &lt;strong&gt;无序集合&lt;/strong&gt; |  |
| unordered_map | 用哈希函数组织的map |
| unordered_set | 用哈希函数组织的set |
| unordered_mulitmap | 哈希组织的map；关键字可以重复出现 |
| unordered_multiset | 哈希组织的set；关键字可以重复出现 |&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有序容器的关键字类型&#34;&gt;有序容器的关键字类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的&amp;lt;运算符。所提供的操作必须在关键字类型上定义一个&lt;strong&gt;严格弱序&lt;/strong&gt;。可以讲严格弱序看作&amp;quot;小于等于&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用关键字类型的比较函数&#34;&gt;使用关键字类型的比较函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了制定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。
在定义时我们必须提供两个类型：关键字类型，以及比较操作类型——函数指针类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pair&#34;&gt;pair&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;pair是一个标准库类型，它定义在头文件utility中。&lt;/li&gt;
&lt;li&gt;一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，必须提供两个类型名，pair的数据成员将具有对应的类型。&lt;/li&gt;
&lt;li&gt;pair的数据成员是public的。两个成员分别命名为first和second。用普通的成员访问符号来访问它们。可以用make_pair来生成pair对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关联容器操作&#34;&gt;关联容器操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;关联容器额外的类型别名&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;key_value&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;此容器类型的关键字类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;mapped_type&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;每个关键字关联的类型；只适用于map&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;value_type&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对于set，与key_type相同；对于map，为pair&amp;lt;const key_type , mapped_type&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。在map中，元素是关键字-值对。即，每个元素是一个pair对象，包含一个关键字和一个关联的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;关联容器迭代器&#34;&gt;关联容器迭代器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对于map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;set的迭代器是const的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;map的下标操作&#34;&gt;map的下标操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;map和unordered_map容器提供了下标运算符和at函数。set类型不支持下标。multimap和unordered_multimap不能进行下标操作，可能有多个值与一个关键字相关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;访问元素&#34;&gt;访问元素&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;关联容器额外的类型别名&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;lower_bound和upper_bound不适用于无序容器&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;下标和at操作只适用于非const的map和unordered_map&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.find(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.count(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.lower_bound(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器，指向第一个关键字&lt;strong&gt;不小于&lt;/strong&gt;k的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.upper_bound(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器，指向第一个关键字&lt;strong&gt;大于&lt;/strong&gt;k的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c.equal_range(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;对map使用find代替下标&#34;&gt;对map使用find代替下标&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对map和unordered_map类型，使用下标操作可能会导致：如果关键字未在map中，下标操作会插入一个具有给定关键字的元素。在指向知道给定关键字是否在map中，应当使用find。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;multimap或multiset中查找元素&#34;&gt;multimap或multiset中查找元素&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对于允许重复关键字的容器来说，在容器中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。可以通过以下步骤实现找到所有的映射。
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、使用count和find实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过count找到给定关键字的数量&lt;/li&gt;
&lt;li&gt;通过find得到一个迭代器指向第一个关键字&lt;/li&gt;
&lt;li&gt;循环次数为count的返回值，读取所有的映射&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、还可以通过面向迭代器的方法解决这个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果查找的元素具有容器中最大的关键字，则此关键字的upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lowe_bound返回的也是尾后迭代器。可以通过如下循环实现读取&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;for ( auto beg = x.lowe_bound(id) , end = x.upper_bound(id) ; beg != end ; ++beg )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;此处代码与count和find能完成相同的工作，但更直接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、equal_range函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;for (auto pos = x.equal_range(id) ; pos.first != pos.second ; ++pos.first)
与使用upper_bound和lower_bound功能一直，但没有使用局部变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>codeforces</title>
      <link>https://wangwei9160.github.io/post/codeforces634/</link>
      <pubDate>Wed, 15 Apr 2020 01:00:00 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/codeforces634/</guid>
      
        <description>&lt;h1 id=&#34;codeforces&#34;&gt;codeforces&lt;/h1&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;A. Candies and Two Sisters&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;B. Construct the String&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;C. Two Teams Composing&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;D. Anti-Sudoku&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;E. Three Blocks Palindrome&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-idaa-candies-and-two-sistersa&#34;&gt;&lt;!-- raw HTML omitted --&gt;A. Candies and Two Sisters&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h5 id=&#34;题目&#34;&gt;题目：&lt;/h5&gt;
&lt;p&gt;There are two sisters Alice and Betty. You have n candies. You want to distribute these n candies between two sisters in such a way that:&lt;br&gt;
lice will get a (a&amp;gt;0) candies;
Betty will get b (b&amp;gt;0) candies;
each sister will get some integer number of candies;
Alice will get a greater amount of candies than Betty (i.e. a&amp;gt;b);
all the candies will be given to one of two sisters (i.e. a+b=n).
Your task is to calculate the number of ways to distribute exactly n candies between sisters in a way described above. Candies are indistinguishable.&lt;br&gt;
Formally, find the number of ways to represent n as the sum of n=a+b, where a and b are positive integers and a&amp;gt;b&amp;hellip;
You have to answer t independent test cases.&lt;/p&gt;
&lt;h4 id=&#34;题意&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;The answer is (n-1)/2&lt;/p&gt;
&lt;h4 id=&#34;代码&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		int n;cin &amp;gt;&amp;gt; n;
		cout &amp;lt;&amp;lt; (n - 1) / 2 &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;B. Construct the String&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目-1&#34;&gt;题目：&lt;/h4&gt;
&lt;p&gt;You are given three positive integers n, a and b. You have to construct a string s of length n consisting of lowercase Latin letters such that each substring of length a has exactly b distinct letters. It is guaranteed that the answer exists.&lt;br&gt;
You have to answer t independent test cases.&lt;br&gt;
Recall that the substring s[l…r] is the string $s_l$,$s_{l+1}$,…,$s_r$ and its length is r?l+1. In this problem you are only interested in substrings of length a.&lt;/p&gt;
&lt;h4 id=&#34;题意-1&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;There is no substring containing more than b distinct characters and each substring of length a contains exactly b distinct characters because of the condition b?a.&lt;/p&gt;
&lt;h4 id=&#34;代码-1&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		int n, a, b;
		cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        string ans=&amp;quot;&amp;quot;;int k=0;
		for (int i = 0; i &amp;lt; n; ++i) {
			ans += &#39;a&#39;+k;
            k = (k+1)%b;
		}
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;C. Two Teams Composing&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目-2&#34;&gt;题目：&lt;/h4&gt;
&lt;p&gt;You have n students under your control and you have to compose exactly two teams consisting of some subset of your students. Each student had his own skill, the i-th student skill is denoted by an integer ai (different students can have the same skills).&lt;br&gt;
So, about the teams. Firstly, these two teams should have the same size. Two more constraints:&lt;br&gt;
The first team should consist of students with distinct skills (i.e. all skills in the first team are unique). &lt;br&gt;
The second team should consist of students with the same skills (i.e. all skills in the second team are equal).&lt;br&gt;
Note that it is permissible that some student of the first team has the same skill as a student of the second team.
Consider some examples (skills are given): &lt;br&gt;
[1,2,3], [4,4] is not a good pair of teams because sizes should be the same;&lt;br&gt;
[1,1,2], [3,3,3] is not a good pair of teams because the first team should not contain students with the same skills;&lt;br&gt;
[1,2,3], [3,4,4] is not a good pair of teams because the second team should contain students with the same skills;&lt;br&gt;
[1,2,3], [3,3,3] is a good pair of teams;&lt;br&gt;
[5], [6] is a good pair of teams.&lt;br&gt;
Your task is to find the maximum possible size x for which it is possible to compose a valid pair of teams, where each team size is x (skills in the first team needed to be unique, skills in the second team should be the same between them). A student cannot be part of more than one team.&lt;br&gt;
You have to answer t independent test cases.&lt;/p&gt;
&lt;h4 id=&#34;题意-2&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;The number of different skills is diff.The number of skill i is $cnt_i$ .&lt;br&gt;
maxcnt = max($cnt_1$,$cnt_2$,…,$cnt_n$).&lt;br&gt;
The answer is max( min(diff?1,maxcnt) , min(diff,maxcnt?1) ).&lt;/p&gt;
&lt;h4 id=&#34;代码-2&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		int n;
		cin &amp;gt;&amp;gt; n;
		vector&amp;lt;int&amp;gt; cnt(n + 1);
		for (int i = 0; i &amp;lt; n; ++i) {
			int x;
			cin &amp;gt;&amp;gt; x;
			++cnt[x];
		}
		int mx = *max_element(cnt.begin(), cnt.end());
		int diff = n + 1 - count(cnt.begin(), cnt.end(), 0);
		cout &amp;lt;&amp;lt; max(min(mx - 1, diff), min(mx, diff - 1)) &amp;lt;&amp;lt; endl;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;D. Anti-Sudoku&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目-3&#34;&gt;题目：&lt;/h4&gt;
&lt;p&gt;You are given a correct solution of the sudoku puzzle.&lt;br&gt;
Blocks are bordered with bold black color.&lt;br&gt;
Your task is to change at most 9 elements of this field (i.e. choose some 1?i,j?9 and change the number at the position (i,j) to any other number in range [1;9]) to make it anti-sudoku. The anti-sudoku is the 9×9 field, in which:&lt;br&gt;
Any number in this field is in range [1;9];&lt;br&gt;
each row contains at least two equal elements;&lt;br&gt;
each column contains at least two equal elements;&lt;br&gt;
each 3×3 block (you can read what is the block in the link above) contains at least two equal elements.&lt;br&gt;
It is guaranteed that the answer exists.&lt;br&gt;
You have to answer t independent test cases.&lt;/p&gt;
&lt;h4 id=&#34;题意-3&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;Well, if we replace all occurrences of the number 2 with the number 1, then the initial solution will be anti-sudoku. It is easy to see that this replacement will make exactly two copies of 1 in every row, column, and block. There are also other correct approaches but I found this one the most pretty.&lt;/p&gt;
&lt;h4 id=&#34;代码-3&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() {
	int t;
	cin &amp;gt;&amp;gt; t;
	while (t--) {
		for (int i = 0; i &amp;lt; 9; ++i) {
			string s;
			cin &amp;gt;&amp;gt; s;
			for (auto &amp;amp;c : s) if (c == &#39;2&#39;) c = &#39;1&#39;;
			cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;E. Three Blocks Palindrome&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;题意-4&#34;&gt;题意：&lt;/h4&gt;
&lt;p&gt;The only difference between easy and hard versions is constraints.&lt;br&gt;
You are given a sequence a consisting of n positive integers.&lt;br&gt;
Let&amp;rsquo;s define a three blocks palindrome as the sequence, consisting of at most two distinct elements (let these elements are a and b, a can be equal b) and is as follows: [$\underbrace{a,a,…,a}&lt;em&gt;\text{x}$,$\underbrace{b,b,…,b}&lt;/em&gt;\text{y}$,$\underbrace{a,a,…,a}_\text{x}$]. There x,y are integers greater than or equal to 0. For example, sequences [], [2], [1,1], [1,2,1], [1,2,2,1] and [1,1,2,1,1] are three block palindromes but [1,2,3,2,1], [1,2,1,2,1] and [1,2] are not.&lt;br&gt;
Your task is to choose the maximum by length subsequence of a that is a three blocks palindrome.&lt;br&gt;
You have to answer t independent test cases.&lt;br&gt;
Recall that the sequence t is a a subsequence of the sequence s if t can be derived from s by removing zero or more elements without changing the order of the remaining elements. For example, if s=[1,2,1,3,1,2,1], then possible subsequences are: [1,1,1,1], [3] and [1,2,1,3,1,2,1], but not [3,2,3] and [1,1,1,1,2].&lt;/p&gt;
&lt;h4 id=&#34;代码-4&#34;&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    int t;cin&amp;gt;&amp;gt;t;
    while(t--){
        int n;cin&amp;gt;&amp;gt;n;
        vector&amp;lt;int&amp;gt; a(n,0);
        const int M = 200;
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; pre(M,vi(n+1));
        vector&amp;lt;vi&amp;gt; at(M);
        for(int i = 0 ; i &amp;lt; n ; i++){
            cin &amp;gt;&amp;gt;a[i];
            --a[i];
            at[a[i]].push_back(i);
        }
        for(int i = 0 ; i &amp;lt; M ; i++){
            for(int j = 0 ; j &amp;lt; n ; j++){
                pre[i][j+1] = pre[i][j] + (a[j]==i);
            }
        }
        int ans = 0;
        for(int i = 0 ; i &amp;lt; M ; i++){
            int k = pre[i][n];
            ans = max(ans,k);
            for(int j = 1 ; 2*j &amp;lt;= k ; j++){
                int bi = at[i][j-1];
                int ed = at[i][k-j];
                for(int t = 0 ; t &amp;lt; M ; t++){
                    if(t!=i){
                        ans = max(ans,j*2 + pre[t][ed]-pre[t][bi]);
                    }
                }
            }
        }
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;返回目录&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>leetcode第184场周赛</title>
      <link>https://wangwei9160.github.io/post/leetcode%E5%91%A8%E8%B5%9B184/</link>
      <pubDate>Sun, 12 Apr 2020 18:00:00 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/leetcode%E5%91%A8%E8%B5%9B184/</guid>
      
        <description>&lt;h1 id=&#34;leetcode第184场周赛&#34;&gt;leetcode第184场周赛&lt;/h1&gt;
&lt;h3 id=&#34;a-id0目录a&#34;&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#a-id1%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Da&#34;&gt;数组中的字符串匹配&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id2-%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97a&#34;&gt;查询带键的排列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id3-html-%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8a&#34;&gt;HTML 实体解析器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#a-id4%E7%BB%99-n-x-3-%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0-a&#34;&gt;给 N x 3 网格图涂色的方案数&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-id1数组中的字符串匹配a&#34;&gt;&lt;!-- raw HTML omitted --&gt;数组中的字符串匹配&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h6 id=&#34;题目&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;利用find函数直接暴力匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; stringMatching(vector&amp;lt;string&amp;gt;&amp;amp; words) {
    vector&amp;lt;string&amp;gt; ans;
    for(auto x : words){
        for(auto y : words){
            if(x == y) continue;
            if(y.find(x) != -1 ){ans.push_back(x);break;}
        }
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id2-查询带键的排列a&#34;&gt;&lt;!-- raw HTML omitted --&gt; 查询带键的排列&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h6 id=&#34;题目-1&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始，排列 P=[1,2,3,&amp;hellip;,m]。&lt;/li&gt;
&lt;li&gt;对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是queries[i] 的查询结果。
请你以数组形式返回待查数组  queries 的查询结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路-1&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;模拟一遍就好了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-1&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; processQueries(vector&amp;lt;int&amp;gt;&amp;amp; queries, int m) {
    int mp[1002];
    for(int i = 0 ; i &amp;lt; m ; i++){
        mp[i] = i+1;
    }
    vector&amp;lt;int&amp;gt; ans;
    for(auto x : queries){
        if(mp[0] == x) {ans.push_back(0);continue;}
        int j = m-1;
        while( j &amp;gt; 0 &amp;amp;&amp;amp; mp[j] != x) {j--;}
        ans.push_back(j);
        for(int k = j ; k &amp;gt; 0 ; k--){
            mp[k] = mp[k-1];
        }
        mp[0] = x;
        
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id3-html-实体解析器a&#34;&gt;&lt;!-- raw HTML omitted --&gt; HTML 实体解析器&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h6 id=&#34;题目-2&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。
HTML 里这些特殊字符和它们对应的字符实体包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号：字符实体为 &amp;quot; ，对应的字符是 &amp;quot; 。&lt;/li&gt;
&lt;li&gt;单引号：字符实体为 &#39; ，对应的字符是 &#39; 。&lt;/li&gt;
&lt;li&gt;与符号：字符实体为 &amp;amp; ，对应对的字符是 &amp;amp; 。&lt;/li&gt;
&lt;li&gt;大于号：字符实体为 &amp;gt; ，对应的字符是 &amp;gt; 。&lt;/li&gt;
&lt;li&gt;小于号：字符实体为 &amp;lt; ，对应的字符是 &amp;lt; 。&lt;/li&gt;
&lt;li&gt;斜线号：字符实体为 ⁄ ，对应的字符是 / 。
给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路-2&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;利用replace函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-2&#34;&gt;代码：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;def entityParser(self, text: str) -&amp;gt; str:
    text = text.replace(&#39;&amp;amp;quot;&#39;,&#39;&amp;quot;&#39;)
    text = text.replace(&#39;&amp;amp;apos;&#39;,&#39;\&#39;&#39;)
    text = text.replace(&#39;&amp;amp;amp;&#39;,&#39;&amp;amp;&#39;)
    text = text.replace(&#39;&amp;amp;gt;&#39;,&#39;&amp;gt;&#39;)
    text = text.replace(&#39;&amp;amp;lt;&#39;,&#39;&amp;lt;&#39;)
    text = text.replace(&#39;&amp;amp;frasl;&#39;,&#39;/&#39;)
    return text
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;a-id4给-n-x-3-网格图涂色的方案数-a&#34;&gt;&lt;!-- raw HTML omitted --&gt;给 N x 3 网格图涂色的方案数 &lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h6 id=&#34;题目-3&#34;&gt;题目：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;你有一个 n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。
给你网格图的行数 n 。
请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;思路-3&#34;&gt;思路：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;初始化第一行的所有状态
接下来计算每一行的所有状态的出现的次数
条件（相同水平边或者垂直边的格子颜色不同）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;代码-3&#34;&gt;代码:&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;long long dp[5002][3][3][3];
const int mod = 1e9+7;
int numOfWays(int n) {
    for(int i=0;i&amp;lt;3;i++)for(int j=0;j&amp;lt;3;j++)for(int k=0;k&amp;lt;3;k++)if(i!=j&amp;amp;&amp;amp;j!=k) dp[1][i][j][k]=1;
    for(int p=2;p&amp;lt;=n;p++){
        for(int i=0;i&amp;lt;3;i++)
            for(int j=0;j&amp;lt;3;j++)
                for(int k=0;k&amp;lt;3;k++)
                    for(int ii=0;ii&amp;lt;3;ii++)
                        for(int jj=0;jj&amp;lt;3;jj++)
                            for(int kk=0;kk&amp;lt;3;kk++)
                                if(i!=j&amp;amp;&amp;amp;j!=k&amp;amp;&amp;amp;ii!=i&amp;amp;&amp;amp;jj!=j&amp;amp;&amp;amp;kk!=k) 
                                    (dp[p][i][j][k] += dp[p-1][ii][jj][kk]) %= mod;
    }
    long long ans =0;
    for(int i=0;i&amp;lt;3;i++)for(int j=0;j&amp;lt;3;j++)for(int k=0;k&amp;lt;3;k++)if(i!=j&amp;amp;&amp;amp;j!=k) ans+=dp[n][i][j][k];
    ans%=mod;
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;#a-id0%E7%9B%AE%E5%BD%95a&#34;&gt;回到目录&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Min_max</title>
      <link>https://wangwei9160.github.io/post/min_max/</link>
      <pubDate>Thu, 09 Apr 2020 21:22:44 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/min_max/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>New_test</title>
      <link>https://wangwei9160.github.io/post/new_test/</link>
      <pubDate>Wed, 08 Apr 2020 21:59:56 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/new_test/</guid>
      
        <description>&lt;p&gt;这里是一篇最新的测试文章！&lt;/p&gt;
&lt;p&gt;重新测试！&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Blog</title>
      <link>https://wangwei9160.github.io/post/blog/</link>
      <pubDate>Wed, 08 Apr 2020 17:25:04 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/blog/</guid>
      
        <description>&lt;p&gt;Hello world!&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>markdown</title>
      <link>https://wangwei9160.github.io/post/markdown/</link>
      <pubDate>Wed, 08 Apr 2020 17:25:04 +0800</pubDate>
      
      <guid>https://wangwei9160.github.io/post/markdown/</guid>
      
        <description>&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;
&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;
&lt;h3 id=&#34;三级标题&#34;&gt;三级标题&lt;/h3&gt;
&lt;h4 id=&#34;四级标题&#34;&gt;四级标题&lt;/h4&gt;
&lt;h5 id=&#34;五级标题&#34;&gt;五级标题&lt;/h5&gt;
&lt;h6 id=&#34;六级标题&#34;&gt;六级标题&lt;/h6&gt;
&lt;h1 id=&#34;我是一级标题&#34;&gt;我是一级标题&lt;/h1&gt;
&lt;h2 id=&#34;我是二级标题&#34;&gt;我是二级标题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;代码&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;import 
&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;4个空格代码块
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;123&lt;/li&gt;
&lt;li&gt;345&lt;/li&gt;
&lt;li&gt;123&lt;br&gt;
1.234&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;123
&lt;ul&gt;
&lt;li&gt;234&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;456
&lt;ul&gt;
&lt;li&gt;98&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;倾斜的字&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;加粗的字&lt;/strong&gt;&lt;br&gt;
正常的字&lt;br&gt;
&lt;em&gt;斜的字&lt;/em&gt;&lt;br&gt;
&lt;del&gt;被删除的字&lt;/del&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;粗斜的字&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;下划线&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;分割线&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;创建脚注格式类似这样 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第三层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一项
&lt;blockquote&gt;
&lt;p&gt;区块1&lt;br&gt;
区块2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baidu.com&#34;&gt;百度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baidu.com&#34;&gt;https://www.baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.baidu.com/img/baidu_jgylogo3.gif&#34; alt=&#34;图片&#34; title=&#34;百度&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;表头很长的&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;表头很长的&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;表头很长的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;单元格&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;单元格&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;单元格&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;单元格&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用 &lt;!-- raw HTML omitted --&gt;Ctrl&lt;!-- raw HTML omitted --&gt;+&lt;!-- raw HTML omitted --&gt;Alt&lt;!-- raw HTML omitted --&gt;+&lt;!-- raw HTML omitted --&gt;Del&lt;!-- raw HTML omitted --&gt; 重启电脑&lt;/p&gt;
&lt;p&gt;\   反斜线
`   反引号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;星号
_   下划线
{}  花括号
[]  方括号
()  小括号&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;井字号&#34;&gt;井字号&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;加号&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;减号
.   英文句点
!   感叹号&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git&#34;&gt;Git&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo --theme= --baseUrl=&amp;quot;name.github.io&amp;quot; --buildDrafts
cd public
git add .
git commit -m &amp;quot;&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;这里是脚注1的内容。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
      
    </item>
    
  </channel>
</rss>
