<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>面试题 - Awei</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Awei" />
  <meta name="description" content="面试题 编程语言 c和c&#43;&#43;的特点与区别 C语言： 1、面向过程的结构化语言，易于调试和维护。 2、表现能力和处理能力极强，可以直接访问内存的物理地址" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.68.3" />


<link rel="canonical" href="https://wangwei9160.github.io/post/interview/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.af20b78e95c84de86b00a0242a4a77bd2601700e1b250edf27537d957ac0041d.css" integrity="sha256-ryC3jpXITehrAKAkKkp3vSYBcA4bJQ7fJ1N9lXrABB0=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="面试题" />
<meta property="og:description" content="面试题 编程语言 c和c&#43;&#43;的特点与区别 C语言： 1、面向过程的结构化语言，易于调试和维护。 2、表现能力和处理能力极强，可以直接访问内存的物理地址" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangwei9160.github.io/post/interview/" />
<meta property="article:published_time" content="2021-03-25T12:08:09+08:00" />
<meta property="article:modified_time" content="2021-03-25T12:08:09+08:00" />
<meta itemprop="name" content="面试题">
<meta itemprop="description" content="面试题 编程语言 c和c&#43;&#43;的特点与区别 C语言： 1、面向过程的结构化语言，易于调试和维护。 2、表现能力和处理能力极强，可以直接访问内存的物理地址">
<meta itemprop="datePublished" content="2021-03-25T12:08:09&#43;08:00" />
<meta itemprop="dateModified" content="2021-03-25T12:08:09&#43;08:00" />
<meta itemprop="wordCount" content="12082">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="面试题"/>
<meta name="twitter:description" content="面试题 编程语言 c和c&#43;&#43;的特点与区别 C语言： 1、面向过程的结构化语言，易于调试和维护。 2、表现能力和处理能力极强，可以直接访问内存的物理地址"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Awei</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/post/">博客</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://gohugo.io" rel="noopener" target="_blank">
              关于
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Awei
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/post/">博客</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wangwei9160.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://gohugo.io" rel="noopener" target="_blank">
              关于
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">面试题</h1>
      
      <div class="post-meta">
        <time datetime="2021-03-25" class="post-time">
          2021-03-25
        </time>
        
        <span class="more-meta"> 约 12082 字 </span>
          <span class="more-meta"> 预计阅读 25 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#面试题">面试题</a>
      <ul>
        <li><a href="#编程语言">编程语言</a></li>
        <li><a href="#服务器编程">服务器编程</a></li>
        <li><a href="#网络编程">网络编程</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="面试题">面试题</h2>
<h3 id="编程语言">编程语言</h3>
<h4 id="c和c的特点与区别">c和c++的特点与区别</h4>
<p>C语言：
1、面向过程的结构化语言，易于调试和维护。
2、表现能力和处理能力极强，可以直接访问内存的物理地址。
3、实现了对硬件的编程操作，也适合于应用软件开发。
4、效率高，可移植性强。
C++：
1、在C语言的基础上进行了扩充和完善，使C++兼容了C语言的面向过程的特点。
2、可以使用抽象数据类型进行基于对象的编程。
3、使用多继承、多态进行面向对象的编程。
4、以模板为特征的泛化编程。</p>
<h4 id="动态绑定">动态绑定</h4>
<p>函数的运行版本由实参决定，即在运行时选择函数的版本，叫动态绑定，主要通过虚函数表来实现。</p>
<h4 id="多态">多态</h4>
<p>静态多态：编译时多态，主要包括参数多态、过载多态和强制多态。
- 参数多态：采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。函数模板和类模板属于参数多态。参数多态又叫静态多态，执行速度快，异常少，调用在编译时已经确定。
- 过载多态：同一个名字在不同的上下文中代表的含义不同。典型的例子是运算符重载和函数重载。
- 强制多态：编译程序通过语义操作，把操作对象的类型强行改变，以符合函数或操作符的要求。例如int+double，就把int强制转换为double，然后执行double+double运算，实现了强制多态。
动态多态：运行时多态，包含多态的基础是虚函数，主要通过继承和虚函数来实现，当基类和子类拥有同名同参数同返回的方法，切该方法声明为虚函数，当基类对象，指针，引用指向的是派生类的对象的时候，基类对象，指针，引用在调用基类的方法，实际上调用的是派生类方法。
如果类中有虚方法，则自动在类中增加一个虚函数指针，该指针指向的是一个虚函数表，虚函数表中存在着每个虚函数真正对应的函数地址。动态多态采用一种延迟绑定技术，普通的函数调用，在编译期间就已经确定调用的函数的地址，所以无论如何调用都是对应的函数。如果是拥有虚函数的类，在调用虚函数时，首先去检查虚函数表，然后在确定调用的是哪一个函数，所以调用的函数是运行时绑定。</p>
<h4 id="多重继承和二义性">多重继承和二义性</h4>
<p>单继承：一个派生类的基类只有一个时称之为单继承。
多重继承：一个派生类的基类有两个或多个，派生类从两个或多个基类中继承所需的属性。
二义性：两个基类中的数据成员名相同，一般在标识符前使用基类名做前缀，借助于域运算符。
二义性发生的情况：
1、两个基类有同名成员：包括成员函数和成员数据。（解决方法：a.使用基类名来限定。例如c.A::a、c.A::display()。b.更清晰的表达:int A::a;int B::a;void A::display();void B::display)(）
2、基类和派生类有同名的成员。（规则：同名覆盖。基类的同名成员在派生类中被屏蔽，认为是&quot;不可见的&rdquo;，对于成员函数，只有函数名和参数个数相同、类型匹配的时候才是同名函数。如果只有函数名相同而参数不同只是重载。）
3、两个基类从同一个基类派生。（解决方法：虚基类。当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次。）</p>
<h4 id="volatile是做什么的使用实例">volatile是做什么的，使用实例</h4>
<p>volatile提醒编译器它后面定义的变量随时可能发生变化，因此编译后的程序在每次需要存储或者读取该变量时，都会直接从变量地址中读取数据。如果没有volatile关键字，程序可能会优化读取和存储，使用暂存在寄存器中的值。主要应用于设备的状态寄存器，中断服务子程序会访问到的非自动变量，多线程应用中被几个任务共享的变量。</p>
<h4 id="static-const的用法">static const的用法</h4>
<h5 id="static">static</h5>
<p>static是修饰符，用来控制变量的存储方式和可见性。
基本用法：
1、在修饰变量的时候，static修饰的局部变量只执行一次初始化，而且延长了局部变量的生命周期，直到程序运行结束以后才会释放。
2、static修饰全局变量的时候，这个全局变量只在本文件中访问，不能在其他文件中访问。
3、static修饰一个函数，则这个函数只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动为0。
4、不想被释放的时候，可以使用static修饰。例如修饰在函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用static修饰。
5、数据安全性。当程序想要使用全局变量的时候应该先考虑static。
在类中的应用：
1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来
2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来。
被static修饰的变量和方法统一属于类的静态资源，是类实例之间共享的。静态成员是属于整个类的而不是某个对象，静态成员变量值存储一份供所有对象共用。所以在所有对象中都可以共享它，使用静态成员变量实现了多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。</p>
<h6 id="const">const</h6>
<p>const主要是防止定义的对象再次被修改，定义对象变量时要初始化变量。
基本用法：
1、用于定义常量变量，这个变量在后面就不可以被再次修改
2、保护传参时参数不被修改，如果使用引用传递参数或按地址传递参数给一个函数，在这个函数里这个参数的值若被修改，则函数外部传进来的变量的值也会发生改变，若想保护传进来的变量不被修改，可以使用const保护。
3、节约内存空间。const定义的变量，系统只为它分配一次内存，而使用#define定义的常量宏，能分配好多次，const能节约空间。
4、类中使用const修饰函数防止修改非static类成员变量。
5、修饰指针const int * p 、int const * p，const修饰指向的变量，p可变，p指向的对象不可变。int * const p，const修饰指针p，p不可变，p指向的对象可变。const int * const A ， 指针p和指针p指向的对象都不可变。
<strong>const位于 * 的左侧，则const就是用来修饰指针所指向的对象，即指针指向的对象是常量；如果const位于 * 的右侧，const就是修饰指针的本身，则指针本身是常量。</strong>
6、修饰函数返回值，防止返回值被改变
7、修饰类的成员变量，使用const修饰的变量必须初始化，在类中不能再定义时初始化。在类的构造函数上初始化。初始化带static类型的变量，在类的外部初始化。
8、const定义的对象变量只能只作用于这个程序，不能被程序的其他文件调用。</p>
<h4 id="const-和-define">const 和 define</h4>
<p>define 只是一个常数的名字，在编译时编译器会把它替换成常数，仅仅是提升了代码的可读性。
const，是一个不能修改其值的变量，const定义的常量在内存中是有自己的地址的。</p>
<h4 id="类的const成员函数">类的const成员函数</h4>
<p>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员。
非const成员函数可以访问非const对象的非const数据成员、const数据成员，不可以访问const对象的任意数据成员。
若成员函数并不对数据成员进行修改，应尽量声明为const成员函数。</p>
<h4 id="const-string-s-和-const-string-s的区别">const string&amp; s 和 const string s的区别</h4>
<p>传参时，const string&amp; s 比const string s更节约资源
值传递和引用传递方式的区别。
值传递，是从调用的地方把值复制一遍传给函数，需要形成实参的副本，有时间和空间的开销，如果是结构体或者类的话开销会更大，函数中对实参副本的修改并不会影响到函数调用位置实参的值。
引用传递，把实参的地址拷贝到形参，形参和实参共用一个内存地址，形参的修改会反映到实参上，32位中指针或者引用的开销只有4字节，开销小。
&amp;的目的是引用，避免了复制，const是为了限定它是只读的。</p>
<h4 id="const-char-s--char-const-s-和-char--const-s的区别">const char *s ， char const *s 和 char * const s的区别</h4>
<p>const 关键字在类型或变量名之前是等价的。声明从右往左读。
char * const s，其中s是一个const指针 指向char类型，不可修改内容。
const char * s，其中s是一个指针 指向const char类型。
char const *s，由于没有没有const *的运算，所以const是修饰char的，与const char * s是一样的。</p>
<h4 id="类的静态数据成员">类的静态数据成员</h4>
<p>static关键字来把类的成员定义为静态的。无论有多少个类的对象，静态成员只有一个。静态成员在所有对象中是共享的。如果不存在其他初始化语句，在创建第一个对象时，所有静态数据都会被初始化为0，不能把静态成员的初始化放在类的定义中，可以再类的外面使用（::）来重新声明静态变量从而对它进行初始化。</p>
<h4 id="静态局部变量和局部变量">静态局部变量和局部变量</h4>
<p>静态变量都在全局数据区分配内存。静态局部变量在程序执行到该对象的声明出首次初始化，即以后的函数调用不再初始化。静态局部变量一般在声明处初始化，如果没有显式初始化，会被自动初始化为0。它始终驻留在全局数据区，知道程序运行结束，但是其作用域仅仅是局部作用域，当定义它的函数或语句结束之后，作用域随之结束。
局部变量的初始值不可知，作用域仅在它的函数或者语句内部，函数或语句结束之后，局部变量也将销毁。</p>
<h4 id="extern-c的作用">extern C的作用</h4>
<p>由于c语言不允许存在同名对象，而c++允许对一个名字基于不同的定义，只要在语义上没有二义性。如果工程中由多个源文件组成，在一个源文件中想引用另外一个源文件中已经定义的全局变量，只需要在引用变量的文件中用到extern关键字声明。</p>
<h4 id="指针-和-引用">指针 和 引用</h4>
<p>指针：对于一个类型T，T* 就是指向T的指针类型，也就是说一个T* 类型的变量能够保存一个T对象的地址。
引用：引用是一个对象的别名，主要用于函数参数和返回值类型，符号T&amp;表示T类型的一个引用。
指针和引用的区别：
1、引用不可以为空，指针可以为空。引用是对象的别名，若引用为空则意味着对象不存在，所以定义一个引用的时候必须初始化。因此当一个变量用于指向另一个对象，如果它可能为空，则应该使用指针，如果不为空，则应该使用引用。
2、指针可以不指向任何对象，因此使用指针之前必须进行判空操作，而引用则不必。引用不可以改变指向，指针可以改变指向，指向其他独享。虽然引用不可以改变指向，但是可以改变初始化对象的内容。如++操作，对引用的操作直接反应到所指向的对象，而不改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。
3、引用的大小是所指向的变量的大小，指针是指针本身的大小，32位系统中是4个字节。
4、引用比指针更安全，不存在空引用，并且引用一旦被初始化为指向一个对象，就不能改变。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。</p>
<h4 id="静态内存分配和动态内存分配">静态内存分配和动态内存分配</h4>
<p>静态内存分配和动态内存分配区别：
1、时间不同。静态分配发生在程序编译和连接的时候，动态分配则发生在程序调入和执行的时候。
2、空间不同。堆是动态分配的，没有静态分配的。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配是由malloc函数进行分配的，栈的动态分配是编译器进行释放的，无需手动进行。</p>
<h4 id="new-和-malloc">new 和 malloc</h4>
<ul>
<li>new/delete 是c++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</li>
<li>new操作返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，new是符合类型安全的操作。malloc内存分配成功返回的是void*，需要使用强制类型转换将void*指针转换成需要的类型。</li>
<li>new内存分配失败返回的是bad_alloc异常。malloc内存分配失败返回的是null。</li>
<li>c++允许重载new/delete操作符，new为对象调用构造函数来完成初始工作。而malloc不允许重载。</li>
<li>new操作从自由存储区上为对象动态分配内存，而malloc函数从堆上动态分配内存。自由存储区是c++基于new操作符的一个抽象概念，凡是通过new进行内存申请，该内存就是自由存储区。而堆是操作系统的术语，是操作系统维护的一块特殊内存，用于程序的内存动态分配。</li>
</ul>
<h4 id="malloc的实质">malloc的实质</h4>
<p>malloc函数有一个将可用的内存块连接为一个链表的空闲链表。调用malloc函数的时候，沿着链表寻找一个大小足以满足用户请求所需要的的内存块。然后将内存块一分为二（一块与用户请求的大小相等，另一块就是剩下的字节）。将分配给用户的内存传给用户，剩下的返回到链表上。调用free时，将用户释放的内存块连接到空闲链表上。到最后，空闲链表就会被切成很多小的内存片段。如果请求一个很大的内存片段，空闲链表上没有可以满足的片段，则malloc请求延时，将空闲链进行整理合并。如果依旧无法满足要求，则返回null。malloc内存不一定分配成功。</p>
<h4 id="内存泄漏">内存泄漏</h4>
<p>已动态分配的内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃等后果。</p>
<h5 id="智能指针">智能指针</h5>
<p>智能指针的行为与常规指针类似，重要的区别是它负责自动的释放所指向的对象。主要有两种智能指针：shared_ptr和unique_ptr。两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针共同指向同一个对象，只有当最后一个shared_ptr析构时，内存才会被释放。unique_ptr独占所指向的对象。还有weak_ptr是个弱引用，主要指向shared_ptr类型所指向的对象，不会改变shared_ptr的引用计数，即使有weak_ptr指向最后一个指对象的shared_ptr被销毁，对象还是会被释放。</p>
<h5 id="手写智能指针拷贝构造运算符">手写智能指针，拷贝构造运算符</h5>
<pre><code>template&lt;class T&gt;
class my_shared_ptr{
    private:
        T* ptr = nullptr;
        int num = 0;
    public:
        my_shared_ptr() {};
        my_shared_ptr(nullptr) {};
        my_shared_ptr(T* ptr) : ptr(p) {num = 1};
        my_shared_ptr(const my_shared_ptr&amp; p) : ptr(p.ptr) , num(p.num) {
            if(num) ++num;
        };
        my_shared_ptr(my_shared_ptr&amp; p) {
            std::swap(ptr,p.ptr);
            std::swap(num,p.num);
        };
        ~my_shared_ptr() {
            if(num &amp;&amp; !(--num)){
                delete ptr;
                ptr = nullptr;
                num = 0;
            }
        }
        T* get(){
            return ptr;
        }
        int use_count(){
            return num;
        }
}
</code></pre><h4 id="头文件中的ifndefdefineendif">头文件中的ifndef/define/endif</h4>
<p>防止头文件被重复包含和编译。头文件的重复包含会导致增大程序大小，重复编译增加编译时间。主要是防止一个源文件两次包含同一个头文件。
主要危害是：1、重复定义。2、无限编译
例如有test.cpp、a.h、b.h 其中test.cpp中include了a.h和b.h，a.h中include了b.h，而b.h中定义了一个变量b，则导致test.cpp中重复定义了变量b。</p>
<h4 id="预处理命令define定义一个常量用来表示一年中有多少秒">预处理命令#define定义一个常量，用来表示一年中有多少秒</h4>
<p>#define SECOND_PER_YEAR (60<em>60</em>24*356)UL</p>
<h4 id="预处理器标识error">预处理器标识#error</h4>
<p>编译程序时，只要遇到#error就会跳出一个编译错误。主要目的是为了保证程序是按所想要的情况进行编译。
当不太确定是否定义了XX的时候，就可以使用#ifdef XXX #error &ldquo;XXX has been defined&rdquo; #else # endif。来提示宏XXX已经被定义了。</p>
<h4 id="struct-和-class">struct 和 class</h4>
<p>区别：
1、默认的继承访问权。class默认的是private，struct默认的是public
2、默认的访问权限。struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。
3、class还用于定义模板参数，像&rsquo;typename&rsquo;。struct不用于定义模板参数。
4、class和struct在大括号上的区别：
- class和struct如果定义了构造函数的话，都不能使用大括号进行初始化
- 如果没有定义构造函数，struct可以用大括号初始化。
- 如果没有定义构造函数，且所有成员变量全是public的话，class可以使用大括号初始化。
struct更适合看成一个数据结构的实现体，class更适合看成是一个对象的实现体。</p>
<h4 id="派生类-和-虚函数">派生类 和 虚函数</h4>
<p>派生类，必须通过使用类派生列表来明确指出它是从哪个基类继承而来的。类派生列表的形式是一个冒号后面紧跟以逗号隔开的基类列表。
虚函数，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于一些函数，基类希望它的派生类各自定义适合自身的版本。
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，也可以不添加，派生类可以显式地注明它将使用哪个成员函数改写基类的虚函数，且具体措施是在该函数的形参列表之后增加一个override关键字。</p>
<h4 id="虚函数和纯虚函数">虚函数和纯虚函数</h4>
<p>定义一个函数为虚函数是为了允许基类的指针来调用子类的函数，定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的必须实现这个函数。
纯虚函数：纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但是要求所有派生类都要定义自己的实现方法，在基类中实现纯虚函数的方法是在函数原型后面加上&quot;=0&rdquo;
纯虚函数的意义是让所有的类对象都可以执行纯虚函数的动作，但是类无法为纯虚函数提供一个合理的默认实现，所以类纯虚函数的生命就是在告诉子类的设计者，必须提供一个纯虚函数的实现，我不需要知道你是怎样实现它。</p>
<h4 id="虚函数表即其内存分配">虚函数表即其内存分配</h4>
<p>虚函数是通过一张虚函数表来实现的。在这个表中，主要是一个类的虚函数的地址表。若父类已经定义的virtual函数，当子类没有显示的重写(override)，则子类直接继承父类的虚函数实现，子类直接复制父类的虚表；当子类有显式的重写(virtual)，则会被当成对父类的改写，编译器会把该子类函数的地址放到该子类虚表中。编译器必须要保证虚函数表的指针存在于对象实例中最前面的位置。这意味着可以通过对象实例的地址得到这张虚函数表，然后遍历其中的函数指针，就可以调用相应的函数。
虚函数表位于只读数据段，即内存的常量区，而虚函数位于代码段，位于代码区。</p>
<h4 id="哪些不能是虚函数">哪些不能是虚函数</h4>
<p>1、**不支持普通函数作为虚函数。**普通函数只能被overload，不能被override，声明为虚函数也没有作用，编译器依旧在编译时绑定。
2、**不支持构造函数作为虚函数。**主要是考虑到语义上的问题。由于构造函数本来就是为了明确初始化对象成员才产生的，然后virtual function主要是为了在不了解细节的情况下也能正确处理对象。virtual函数是使不同类型的对象产生不同的动作，如果对象没有产生，如何使用virtual来完成想要的动作。a.构造函数不能被继承，因此不能被声明为virtual函数。b.构造函数一般是用来初始化对象，只有一个对象生成之后，才能发挥多态。
3、**不支持内联成员函数为虚函数。**内联函数主要为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承之后对象能准确执行自己的动作。inline函数在编译时被展开，而虚函数是在运行是才被动态绑定的。两者有着本质的区别。
4、**不支持静态成员函数为虚函数。**静态成员函数对于每个类来说都只有一份，所有的对象都共享这一份代码，没有进行动态绑定的必要，且不能被继承。
5、**不支持友元函数为虚函数。**不支持友元函数的继承，对于没有继承特性的函数就没有虚函数的说法。</p>
<h4 id="抽象类">抽象类</h4>
<p>抽象类是一种特殊的类，它是为了抽象和设计的目的建立的，它处于继承层次结构的较上层。
1、抽象类的定义：带有纯虚函数的类称为抽象类。
2、抽象类的作用：抽象类的主要作用是将有关的操作作为接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
3、使用抽象类注意事项：
- 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出，如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然是一个抽象类。如果实现了纯虚函数，就不再是抽象类，就可以建立对象了。
- 抽象类不能定义对象。</p>
<h4 id="派生新类的过程">派生新类的过程</h4>
<p>派生新类的过程一般要经历三个步骤:吸收基类成员、改造基类成员、添加新的成员。</p>
<h4 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h4>
<p>编译器在我们没有定义拷贝构造函数的时候，会在拷贝对象时调用默认拷贝构造函数，进行的是浅拷贝。对指针进行拷贝之后会出现两个指针指向同一个内存空间。在对含有指针成员的对象进行拷贝的时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即深拷贝，这样就避免了内存泄漏。浅拷贝只是对指针的拷贝，深拷贝不仅对指针进行拷贝，还对指针指向的对象进行拷贝。浅拷贝带来的问题在于析构时多次释放内存，可以使用shared_ptr解决这个问题。</p>
<h4 id="静态关联动态关联">静态关联、动态关联</h4>
<p>在多态中，如果程序在编译阶段就能确定实际执行动作，就叫静态关联。如果等到程序运行时才能确定叫动态关联。</p>
<h4 id="重载">重载</h4>
<p>重载的作用：在同一个作用域内用同一个函数名命名一组功能相似的函数，减少了函数名的数量，避免了名字空间的污染。
函数重载是一种静态多态：多态是指用同一个东西表示不同的形态。函数重载是静态多态，即编译时多态。
编译器在编译.cpp文件中当前使用的作用域里的同名函数时，根据函数形参的类型和顺序会对函数进行重命名。C语言中编译器在编译.c文件时，指挥对函数进行简单的重命名，两个函数名相同的函数在编译之后也照样相同。调用时就不知道到底调用哪一个而出错。</p>
<h4 id="类型转换">类型转换</h4>
<p>1、static_cast：用于非多态类型的静态转换，对应于c中的隐式类型转换，但不能用于两个不想关类型的转换，例如整型和整型指针之间的转换。
2、reinterpret_cast：重新解释，可以将一种类型转换成另一种不相关类型，对于c中的强制类型转换，处理无法进行隐式转换的情况。
3、const_cast：功能是删除变量的const属性，方便再次赋值，该转换在编译时完成，用于解除const、volatile修饰符，只能转换指针或引用。
4、dynamic_cast：通常在基类和派生类之间转换使用。</p>
<h4 id="static_cast-而不用c语言的隐式转换">static_cast 而不用c语言的隐式转换</h4>
<p>c++中的static_cast转换的优势在于能在观看代码时就能够看出这个转换的底层含义或者潜在的风险，而c的转换则看上去是无差别的，不安全的。</p>
<h4 id="右值引用">右值引用</h4>
<p>通过&rdquo; &amp;&amp; &ldquo;而不是&rdquo; &amp; &ldquo;来获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。可以自由地将一个右值引用的资源“移动”到另一个对象中。右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。右值引用主要运用于移动构造和移动赋值、转发。对于一个左值，一般会选择调用拷贝构造函数，这会造成资源的浪费，右值会在执行完之后就销毁，充分利用资源，右值是短暂的。</p>
<h4 id="进程通信">进程通信</h4>
<h3 id="服务器编程">服务器编程</h3>
<h3 id="网络编程">网络编程</h3>
<h4 id="堆和栈">堆和栈</h4>
<p>堆：共有的空间，份全局堆和局部堆。全局堆是所有没有分配的空间，局部堆是用户分配的空间，堆在操作系统对进程初始化的时候分配，运行时也可以向操作系统索要额外的堆，但是用完得还给操作系统，否则就造成内存泄漏。
栈：栈是线程独有的，保存其运行状态和局部变量的。栈在线程开始的时候初始化，每个线程的栈相互独立，每个函数也有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，也就是切换SS/ESP寄存器。
堆空间不足：
栈空间不足：
栈空间存什么：函数的参数值，局部变量的值。
栈内存会被污染：定义一个变量，在修改另一个变量时，导致原油的变量值被修改，被称之为内存污染。栈是从高到低分配地址的，例如有char类型变量a,b，一个int类型指针指向了b所在的地址，给指针所在地址赋值为一个数时，a的地址比b的地址高，赋值会改变a所在地址的内容，造成内存污染。
谁会产生内存碎片：堆会产生内存碎片。
内存碎片怎么产生：malloc函数有一个将可用的内存块连接为一个链表的空闲链表。由于malloc分配时是沿着链表寻找一个大小足以满足用户请求所需的内存块，然后将内存块一分为二，将分配给用户的内存传给用户，剩下的则返回到链表上。调用free时，将用户释放的内存块连接到空闲链表上。到最后，空闲链表就会切成很多小的内存片段。如果请求一个很大的内存片段，空闲链表上没有可以满足的片段，则malloc请求延时，将空闲链进行整理合并。如果依旧无法满足要求，则返回null。malloc内存不一定分配成功。
如何预防内存碎片：1、伙伴算法，用于管理物理内存，避免内存碎片;伙伴系统是把所有的空闲页框分成11个块链表，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框。每个块的第一个页框的物理地址是该块大小的整数倍。假设要请求256个页框的块，步骤主要有两步。第一步，在256个页框的链表中检查是否有一个空闲块，如果没有，则查找下一个更大的块，如果有，则满足请求。第二步，在更大的块即512个页框的链表中检查是否有一个空闲块，如果有，把512个页框的空闲块分成两份，第一份用于满足请求，第二份链接到256个页框的链表中。如果没有空闲块，则继续查找更大的。2、高速缓存Slab层用于管理内核分配内存，避免碎片。</p>
<p>区别：</p>
<ul>
<li>管理方式不同：程序运行时，栈由操作系统自动分配管理，无须程序员人工控制，包括函数的参数值、返回值、局部变量等。而堆空间的申请、释放都是有程序员人工控制，也因此容易产生内存泄漏。</li>
<li>空间大小不同：栈是向低位置扩展，是一块连续的内存区域。即栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将出现栈溢出的错误。而堆是向高地址扩展，是不连续的内存区域。因为系统是链表来存储空间内存地址的，且链表的遍历方向是由低地址向高地址扩展的</li>
<li>产生的碎片：对于堆来说，频繁的malloc/free(new/delete)势必造成内存空间的不连续，从而造成大量的内存碎片，程序的运行效率低下。而对于栈来说，分配的一定是连续的内存空间。</li>
<li>堆都是程序中由malloc/new函数动态申请分配的，有free/delete函数释放；而栈的分配和释放是由操作系统完成的。栈的动态分配有allocate()函数手动完成，但一般都无需手动操作，而是交给编译器自动进行申请和释放的。</li>
<li>分配效率不同：堆的内存分配效率比栈低很多。因为栈有操作系统提供的，会在底层堆栈提供支持，分配专门的寄存器存放栈的地址，包括压栈出栈都由专门的指令执行，所以执行效率高。而堆是由c函数支持的，机制复杂，分配内存时库函数搜索可用的内存空间，如果没有足够的连续的空间，则需要操作系统来重新整理堆内存，这样才有机会分到足够大小的空间，然后返回。</li>
</ul>
<h4 id="信号量">信号量</h4>
<p>信号量的作用：
信号量的同步：</p>
<h4 id="锁">锁</h4>
<p>mutex（互斥锁）、semaphore（信号量）、rw_semaphore（读写信号量）、spanblock（自旋锁）。
mutex：主要实现内核中的互斥访问功能，对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁，不能进行递归锁定或解锁。
semaphore：信号量创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，若初始值为1就变成互斥锁，一个任务想要访问共享资源，首先必须得到信号量，获取信号量的操作会将信号量的值减1，若当前信号量的值为负数，则表示无法获得信号量，若当前信号量的值为非负数，表示可以获得信号量。当任务访问完呗信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务正在等待当前信号量，因此它将被唤醒。
re_semaphore：读写信号量对访问者进行了细分，或是读者或是写者，读者在保持读写信号量期间只能对该信号量保护的共享资源进行读访问，如果一个任务除了读还需要写，就被归类为写者，它在对共享资源访问之前必须先获得写者身份，写者发现自己不需要写访问的情况下可以降级为读者。读写信号量同时拥有的读者数量不限。如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则读者必须被挂起知道写者释放信号量。
spanbloc：自旋锁与互斥锁有点类似，但不会引起调用者睡眠，如果自旋锁已经被别的执行单位保持，则调用者就一直循环在哪里看是否该自选这的保持者已经释放了锁，由于自旋锁使用者保持锁时间非常短，因此选择自选而不是睡眠，自旋锁的小绿远高于互斥锁。
锁的作用：实现对数据的保护。
锁的互斥：使用锁的目的是达到同步的作用，使共享资源在同一时间内，只有能有一个进程或者线程对他进行操作。</p>
<p>管道及有名管道、信号、消息队列、共享内存、信号量、socket。</p>
<h4 id="多线程">多线程</h4>
<p>阻塞还是非阻塞：
是否可以传较大数据、最大多大：
消息队列最多缓存多少消息：
多线程数据同步问题：
多线程数据保护：</p>
<h4 id="线程间通信">线程间通信</h4>
<p>共享内存、消息传递、管道流
共享内存：线程之间共享程序的公共状态，线程之间通过读写内存中的公共状态来隐式通信。使用volatile共享内存
消息传递：线程之间没有公共的状态，线程之间必须明确的发送信息来显式的进行通信。wait/notify等待通知方式（最典型的是生产者-消费者模式）、join方式
管道流：管道输入/输出流的形式</p>
<h4 id="tcp-连接">TCP 连接</h4>
<p>建立一个TCP连接时会发生下述情形：</p>
<ul>
<li>服务器必须准备好接受外来的连接。通过调用socket、bind和listen这3个函数来完成，称之为被动打开(passive open)</li>
<li>客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据包只含有一个IP首部、一个TCP首部及可能有的TCP选项。</li>
<li>服务器必须确认(ACK)客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。</li>
<li>客户必须确认服务器的SYN。
这种交换至少需要3个分组，因此称之为三次握手。</li>
</ul>
<h4 id="socket">socket</h4>
<p>client模型：
server模型：
server如何实现并发处理：
select：
select最大支持多少个fd：1024
socket有几个缓冲区：2个readbuf和writebuf
socket缓冲区如何设置：
UDP缓冲区满了，数据不会丢，为什么
TCP缓冲区满了，数据不会丢，为什么</p>
<h4 id="tcpip">TCP/IP</h4>
<p>TCP UDP 多播协议：
TCP协议的可靠性：
MTU是什么，默认多大：
UDP和多播数据格式的差异：</p>
<h4 id="红黑树">红黑树</h4>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Awei</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2021-03-25
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/stl/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">Stl</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/shell/">
            <span class="next-text nav-default">Shell</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="https://github.com/wangwei9160" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://wangwei9160.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>

  <span class="copyright-year">
    &copy;
    
      2020 -
    2021
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Awei
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
